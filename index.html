<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WH-MURTEDE LOGISTICS - V95 TOTAL CONTROL</title>
    
    <!-- SDKs -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js">
// ===== MASTER DATA UI WIRING =====
document.addEventListener('DOMContentLoaded', function(){
  var ms = document.getElementById('master-search');
  if(ms && !ms.__wired){
    ms.__wired = true;
    ms.addEventListener('input', function(){ try{ updateMasterPreview(); }catch(e){} });
  }
  // render once after load
  setTimeout(function(){ try{ updateMasterPreview(); }catch(e){} }, 700);
});


function exportMasterDB(){
  try{
    var rows = [["barcode","product_name"]];
    Object.keys(masterProductsDB||{}).sort().forEach(function(k){
      rows.push([k, masterProductsDB[k]||""]);
    });
    var csv = rows.map(function(r){
      return r.map(function(v){
        v = (v===undefined||v===null) ? "" : String(v);
        if(v.includes('"') || v.includes(",") || v.includes("\n")) return '"' + v.replace(/"/g,'""') + '"';
        return v;
      }).join(",");
    }).join("\n");
    var blob = new Blob([csv], {type:"text/csv;charset=utf-8;"});
    var url = URL.createObjectURL(blob);
    var a = document.createElement("a");
    a.href = url;
    a.download = "master_products.csv";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    setTimeout(function(){ URL.revokeObjectURL(url); }, 2000);
  }catch(e){ console.error(e); alert("Erro ao exportar."); }
}
window.exportMasterDB = exportMasterDB;

</script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    <!-- EXCEL EXPORT LIBRARY -->
    <script src="https://cdn.sheetjs.com/xlsx-0.20.0/package/dist/xlsx.full.min.js"></script>
    
    <style>
        :root { 
            --primary: #2c3e50; --accent: #3498db; --packing: #28a745; --picking: #8e44ad; --returns: #ff3d00; --error: #e74c3c; --bg: #f4f7f6;
            --color-ctt: #2ecc71; --color-nacex: #9b59b6; --color-correos: #3498db;
            --color-printed: #ff851b; --color-ready: #28a745; --color-packed: #0056b3;
            --color-prepack: #16a085;
        }
        body { font-family: 'Segoe UI', sans-serif; background: #eef2f7; margin: 0; color: #333; overflow-x: hidden; font-size: 16px; }
        
        /* LOGIN */
        #login-screen { position: fixed; inset: 0; background: var(--primary); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 5000; color: white; }
        .login-card { background: white; padding: 40px; border-radius: 20px; width: 380px; color: #333; text-align: center; box-shadow: 0 15px 35px rgba(0,0,0,0.4); }
        .login-card input { width: 100%; padding: 15px; margin: 12px 0; border: 1px solid #ddd; border-radius: 10px; font-size: 18px; box-sizing: border-box; }

        /* NAVBAR */
        .nav-bar { background: #fff; display: flex; justify-content: space-between; align-items: center; padding: 0 30px; border-bottom: 3px solid #ddd; position: sticky; top: 0; z-index: 1000; height: 80px; }
        .nav-item { padding: 25px 15px; cursor: pointer; font-weight: 900; color: #7f8c8d; text-transform: uppercase; font-size: 12px; letter-spacing: 1px; }
        .nav-item.active { color: var(--accent); border-bottom: 5px solid var(--accent); }
        
        .container { max-width: 1800px; margin: 25px auto; padding: 0 25px; }
        .card { background: white; padding: 30px; border-radius: 15px; box-shadow: 0 6px 15px rgba(0,0,0,0.08); margin-bottom: 25px; }
        .section { display: none; }
        .section.active { display: block; }

        /* DASHBOARD */
        .dashboard-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 20px; margin-bottom: 30px; }
        .dash-card { background: white; padding: 25px; border-radius: 15px; text-align: center; box-shadow: 0 4px 10px rgba(0,0,0,0.05); border-bottom: 5px solid #ddd; }
        .dash-card h2 { font-size: 48px; margin: 0; color: var(--primary); }
        .dash-card p { margin: 10px 0 0; font-weight: 900; text-transform: uppercase; font-size: 14px; color: #7f8c8d; }

        /* KANBAN OVERVIEW */
        .mgmt-wrapper { display: flex; gap: 30px; overflow-x: auto; padding-bottom: 30px; align-items: flex-start; }
        .carrier-column { min-width: 380px; max-width: 380px; flex-shrink: 0; background: rgba(0,0,0,0.03); border-radius: 20px; padding: 15px; }
        .carrier-header { border-radius: 12px; color: white; padding: 15px; font-weight: 900; font-size: 18px; text-align: center; margin-bottom: 15px; text-transform: uppercase; }
        .batch-card { background: white; border-radius: 15px; padding: 20px; margin-bottom: 15px; box-shadow: 0 4px 6px rgba(0,0,0,0.02); }
        .progress-container { background: #eee; border-radius: 10px; height: 8px; margin: 12px 0; overflow: hidden; }
        .progress-bar { background: var(--packing); height: 100%; transition: width 0.5s; }

        /* BUTTONS */
        .btn-mobile-op { width: 100%; padding: 20px; font-size: 18px; font-weight: 900; border: none; border-radius: 12px; cursor: pointer; color: white; text-transform: uppercase; transition: 0.2s; margin-bottom: 10px; }
        .btn-op-green { background: var(--packing); }
        .btn-op-purple { background: var(--picking); }
        .btn-op-orange { background: var(--returns); }
        .btn-submit { background: var(--packing); color: white; width: 100%; font-size: 18px; padding: 15px; border: none; border-radius: 10px; cursor: pointer; font-weight: bold; }
        .btn-small { padding: 8px 12px; font-size: 11px; border-radius: 6px; border: none; cursor: pointer; color: white; font-weight: bold; text-transform: uppercase; }
        .btn-delete { background: var(--error) !important; }
        .btn-dismiss { background: #fff; color: var(--error); border: 2px solid var(--error); padding: 10px 20px; border-radius: 8px; font-weight: 900; cursor: pointer; margin-top: 10px; font-size: 16px; }

        /* MODALS */
        .modal { display:none; position:fixed; inset:0; background:rgba(0,0,0,0.8); z-index:6000; justify-content:center; align-items:center; backdrop-filter: blur(5px); }
        .modal-content { background:white; padding:40px; border-radius:25px; width:95%; max-width:1500px; max-height:90vh; overflow-y:auto; box-shadow: 0 20px 50px rgba(0,0,0,0.5); }
        .scroll-area { max-height: 450px; overflow-y: auto; border: 1px solid #ddd; border-radius: 12px; background: #fff; margin-top: 10px; }
        
        table { width: 100%; border-collapse: collapse; font-size: 14px; }
        table th { background: #f1f3f5; position: sticky; top: 0; z-index: 10; padding: 12px; border-bottom: 2px solid #dee2e6; text-align: left; }
        table td { padding: 12px; border-bottom: 1px solid #eee; }

        .prod-tag { background: #eee; padding: 8px 12px; border-radius: 6px; margin: 4px; font-size: 14px; font-weight: bold; display: inline-flex; align-items: center; gap: 8px; border: 1px solid #ccc; }
        .meta-cancel-banner { background: #e74c3c; color: white; padding: 20px; border-radius: 12px; font-weight: 900; text-align: center; margin-bottom: 20px; font-size: 28px; animation: blink 1s infinite; display: flex; flex-direction: column; align-items: center; }
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0.4; } }
        .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 30px; }
        input, textarea, select { width: 100%; padding: 15px; margin: 8px 0; border: 2px solid #ddd; border-radius: 10px; font-size: 16px; box-sizing: border-box; }
        .location-tag { background: #fee2e2; color: #991b1b; padding: 5px 12px; border-radius: 8px; font-weight: 900; font-size: 20px; margin-left: auto; border: 1px solid #f87171; }
    </style>
</head>
<body>

<div id="login-screen">
    <h1>WH-MURTEDE</h1>
    <div class="login-card">
        <input type="email" id="login-email" placeholder="Email (@admin.com / @wh.com)">
        <input type="password" id="login-pass" placeholder="Password">
        <button style="width:100%; background:var(--accent); color:white; border:none; padding:20px; border-radius:12px; cursor:pointer; font-weight:bold; font-size:20px;" onclick="handleLogin()">SIGN IN</button>
    </div>
</div>

<!-- MODAL: DETALHES DO LOTE -->
<div id="edit-batch-modal" class="modal">
    <div class="modal-content">
        <div style="display:flex; justify-content:space-between; align-items:center;">
            <h2 id="edit-batch-title" style="font-size:30px; margin:0;">Batch Details</h2>
            <button class="btn-small btn-delete" id="modal-delete-btn" style="padding:15px 30px; font-size:16px;">DELETE ENTIRE BATCH</button>
        </div>
        <div id="edit-batch-meta" style="margin-top:10px; font-size:14px; color:#444;"></div>
        <hr style="margin:25px 0;">

        <!-- CARRIER EDIT (ADMIN) -->
        <div id="modal-carrier-row" style="display:none; margin: 10px 0 20px 0; padding: 14px 16px; border: 1px solid #e5e7eb; border-radius: 14px; background: #f8fafc;">
            <div style="display:flex; align-items:flex-end; gap:12px; flex-wrap:wrap;">
                <div style="flex:1; min-width:220px;">
                    <label style="font-weight:900; font-size:12px; color:#475569;">üöö Transportadora do Lote</label>
                    <select id="modal-carrier-select" style="height:52px;"></select>
                    <div style="font-size:12px; color:#64748b; margin-top:6px;">Mudar aqui altera a coluna do OVERVIEW e o carrier nos exports (para este lote).</div>
                </div>
                <button id="modal-carrier-save" class="btn-small" style="background: var(--accent); padding: 14px 18px; font-size: 14px; height:52px;" onclick="saveBatchCarrierFromModal()">GUARDAR</button>
                <div id="modal-carrier-status" style="display:none; font-size:12px; color:#0f766e; font-weight:900;"></div>
            </div>
        </div>

        <div style="display:grid; grid-template-columns: 1fr 1.5fr; gap:30px;">
            <div>
                <h4>üì¶ Inventory Status</h4>
                <div class="scroll-area">
                    <table id="edit-inventory-table">
                        <thead><tr id="inv-header"><th>Product</th><th>Qty</th><th>Pos</th><th class="admin-only-cell">Del</th></tr></thead>
                        <tbody></tbody>
                    </table>
                </div>
                <h4>üìä Modification Log</h4>
                <div id="qty-modification-log" style="font-size:11px; background:#f8f9fa; padding:10px; border-radius:10px; height:200px; overflow-y:auto; border:1px solid #ddd; font-family: monospace;"></div>
            </div>
            <div>
                <h4>üÜî Order Mapping & Full Tracking</h4>
                <div class="scroll-area" id="edit-ids-list"></div>
                <h4 style="margin-top:20px; color: var(--error);">üö´ Cancellation Reasons Log</h4>
                <div id="cancelled-ids-log" style="font-size:11px; background:#fff5f5; padding:10px; border-radius:10px; height:150px; overflow-y:auto; border:1px solid #fab1a0; font-family: monospace;"></div>
            </div>
        </div>
        <button class="btn-submit" style="margin-top:35px; background: var(--primary);" onclick="closeModal('edit-batch-modal')">CLOSE WINDOW</button>
    </div>
</div>


<!-- MODAL: EDIT PACKED ITEMS -->
<div id="edit-packed-items-modal" class="modal">
    <div class="modal-content" style="max-width:900px;">
        <div style="display:flex; justify-content:space-between; align-items:center; gap:12px;">
            <h2 id="edit-packed-items-title" style="margin:0;">Edit Packed Items</h2>
            <button class="btn-small btn-delete" onclick="closeModal('edit-packed-items-modal')">CLOSE</button>
        </div>
        <hr style="margin:16px 0;">

        <div style="font-size:13px; color:#666; margin-bottom:10px;">
            Remove apenas os itens picados por engano. O ID mant√©m-se PACKED.
        </div>

        <div id="edit-packed-items-list" style="display:flex; flex-wrap:wrap; gap:10px;"></div>

        <div style="margin-top:16px;">
            <label style="font-weight:900; font-size:12px; color:#666;">Nota (opcional)</label>
            <input id="edit-packed-items-note" placeholder="Ex: removido SKU errado picado pelo operador" />
        </div>

        <button class="btn-submit" style="margin-top:16px; background:#0ea5e9;" onclick="savePackedItemsEditor()">
            SAVE CORRECTION
        </button>
    </div>
</div>

<!-- MODAL: ID HISTORY -->
<div id="id-history-modal" class="modal">
    <div class="modal-content">
        <div style="display:flex; justify-content:space-between; align-items:center; gap:15px;">
            <h2 id="id-history-title" style="font-size:30px; margin:0;">ID History</h2>
            <div style="display:flex; gap:10px; align-items:center;">
                <button class="btn-small" style="background: var(--accent); padding: 14px 18px; font-size: 14px;" onclick="exportIdHistory()">EXPORT THIS ID</button>
                <button class="btn-small btn-delete" style="padding: 14px 18px; font-size: 14px;" onclick="closeModal('id-history-modal')">CLOSE</button>
            </div>
        </div>
        <hr style="margin:20px 0;">
        
        <div style="display:flex; gap:10px; flex-wrap:wrap; margin-bottom: 10px;">
            <div style="min-width:180px; flex:1;">
                <label style="font-weight:900; font-size:12px; color:#666;">Start</label>
                <input type="date" id="modal-start-date">
            </div>
            <div style="min-width:180px; flex:1;">
                <label style="font-weight:900; font-size:12px; color:#666;">End</label>
                <input type="date" id="modal-end-date">
            </div>
            <div style="min-width:220px; flex:1;">
                <label style="font-weight:900; font-size:12px; color:#666;">Type</label>
                <select id="modal-type-filter">
                    <option value="ALL">ALL</option>
                    <option value="OFFICE / BATCH_CREATED">OFFICE / BATCH_CREATED</option>
                    <option value="CANCELLED">CANCELLED</option>
                    <option value="PACKING">PACKING</option>
                    <option value="RETURNS">RETURNS</option>
                </select>
            </div>
            <div style="min-width:220px; flex:1;">
                <label style="font-weight:900; font-size:12px; color:#666;">Status</label>
                <select id="modal-status-filter">
                    <option value="ALL">ALL</option>
                    <option value="PACKED">PACKED</option>
                    <option value="PENDING">PENDING</option>
                    <option value="CANCELLED">CANCELLED</option>
                </select>
            </div>
            <div style="display:flex; align-items:flex-end;">
                <button class="btn-small" style="background: var(--primary); padding: 14px 18px; font-size: 14px;" onclick="applyIdHistoryFilters()">APPLY</button>
            </div>
        </div>

        <div id="id-history-timeline" style="margin-top: 10px; padding: 10px 5px;"></div>

        <div id="id-history-summary" style="background:#f8f9fa; border:1px solid #ddd; padding:15px; border-radius:12px; font-size:14px;"></div>
        <div class="scroll-area" style="margin-top: 15px;">
            <table id="id-history-table">
                <thead>
                    <tr>
                        <th>Date/Time</th>
                        <th>Type</th>
                        <th>Batch</th>
                        <th>Carrier</th>
                        <th>User</th>
                        <th>Tracking</th>
                        <th>Items / Content</th>
                        <th>Details</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
        </div>
    </div>
</div>

<div id="main-interface" style="display:none;">
    <div class="nav-bar">
        <div id="menu-items" style="display:flex;"></div>
        <button onclick="logout()" style="color:var(--error); border:none; background:none; cursor:pointer; font-weight:900; font-size:14px;">LOGOUT</button>
    </div>

    <div class="container">
        
        <!-- SECTION: OVERVIEW -->
        <div id="sec-overview" class="section">
            <div class="card" style="display:flex; justify-content:space-between; align-items:center;">
                <h2 style="margin:0;">üåç Warehouse Overview</h2>
                <input type="date" id="global-date-filter" onchange="syncGlobalData()" style="width:220px;">
            </div>
            <div class="dashboard-grid">
                <div class="dash-card"> <h2 id="card-printed">0</h2> <p>Total Printed</p> </div>
                <div class="dash-card"> <h2 id="card-ready">0</h2> <p>Pending Packing</p> </div>
                <div class="dash-card"> <h2 id="card-packed">0</h2> <p>Packed Today</p> </div>
                <div class="dash-card"> <h2 id="card-prepack">0</h2> <p>Pre-Packed Today</p> </div>
            </div>
            <div id="mgmt-container" class="mgmt-wrapper"></div>
        </div>

        <!-- SECTION: SEARCH (ID HISTORY) -->
        <div id="sec-search" class="section">
            <div class="card">
                <h2>üîç Deep Order Search</h2>
                <p>Paste Order IDs to see full history grouped by ID.</p>
                <textarea id="search-ids-input" rows="4" placeholder="12345678, 87654321"></textarea>
                <div class="grid-2" style="margin-top: 10px;">
                    <div>
                        <label style="font-weight:900; font-size:12px; color:#666;">Start Date</label>
                        <input type="date" id="search-start-date">
                    </div>
                    <div>
                        <label style="font-weight:900; font-size:12px; color:#666;">End Date</label>
                        <input type="date" id="search-end-date">
                    </div>
                </div>
                <div style="margin-top:10px; display:flex; align-items:center; gap:10px;">
                    <input type="checkbox" id="search-all-records" style="width:22px; height:22px;">
                    <label for="search-all-records" style="font-weight:900; font-size:14px; color:#333;">SEARCH ALL RECORDS (slow)</label>
                    <span style="font-size:12px; color:#666;">Use when you don't know the date.</span>
                </div>
                <div class="grid-2" style="margin-top: 10px;">
                    <div>
                        <label style="font-weight:900; font-size:12px; color:#666;">Event Type</label>
                        <select id="search-type-filter">
                            <option value="ALL">ALL</option>
                            <option value="OFFICE / BATCH_CREATED">OFFICE / BATCH_CREATED</option>
                            <option value="CANCELLED">CANCELLED</option>
                            <option value="PACKING">PACKING</option>
                            <option value="RETURNS">RETURNS</option>
                        </select>
                    </div>
                    <div>
                        <label style="font-weight:900; font-size:12px; color:#666;">Status</label>
                        <select id="search-status-filter">
                            <option value="ALL">ALL</option>
                            <option value="PACKED">PACKED</option>
                            <option value="PENDING">PENDING</option>
                            <option value="CANCELLED">CANCELLED</option>
                            <option value="NOT FOUND">NOT FOUND</option>
                        </select>
                    </div>
                </div>

                <button class="btn-submit" style="background: var(--accent); margin-top: 10px;" onclick="searchOrderHistory()">SEARCH HISTORY</button>
                <button class="btn-submit" style="background: var(--packing); margin-top: 10px;" onclick="exportAllSearchHistories()">EXPORT ALL (EXCEL)</button>

                <div id="search-cards-container" style="margin-top: 20px; display: grid; grid-template-columns: repeat(auto-fill, minmax(360px, 1fr)); gap: 15px;"></div>
</div>
            </div>
        </div>

        <!-- SECTION: PERFORMANCE -->
        <div id="sec-performance" class="section">
            <div class="card">
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom: 20px;">
                    <h2 style="margin:0;">üìä Operator Performance</h2>
<div class="card" style="margin-top:14px;">
  <h3 style="margin:0 0 10px 0;">Hist√≥rico por operador (Pre-Packing / Packing / Returns)</h3>
  <div class="grid-2">
    <div>
      <label style="font-weight:900;">Dia</label>
      <input type="date" id="perf-day" style="width:100%; padding:10px; border-radius:10px; border:1px solid #ddd;">
      <div style="font-size:12px; color:#666; margin-top:6px;">Escolhe o dia para an√°lise e hist√≥rico.</div>
    </div>
    <div>
      <label style="font-weight:900;">Operador</label>
      <select id="perf-operator" style="width:100%; padding:10px; border-radius:10px; border:1px solid #ddd;">
        <option value="ALL">Todos</option>
      </select>
      <div style="font-size:12px; color:#666; margin-top:6px;">Filtra o hist√≥rico para um operador espec√≠fico.</div>
    </div>
  </div>

  <div style="display:flex; gap:10px; flex-wrap:wrap; margin-top:12px;">
    <button id="btn-perf-load" style="font-weight:900;">Carregar resumo di√°rio</button>
    <button id="btn-perf-history" style="font-weight:900; background:#334155; color:white;">Ver hist√≥rico detalhado</button>
    <button id="btn-perf-export" style="font-weight:900; background:#0ea5e9; color:white;">Exportar (CSV)</button>
  </div>

  <div id="perf-daily-summary" style="margin-top:14px;"></div>

  <div id="perf-history-wrap" style="display:none; margin-top:14px;">
    <div style="display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap;">
      <h4 style="margin:0;">Hist√≥rico detalhado</h4>
      <div style="font-size:12px; color:#666;">Mostra todos os registos do dia (filtr√°vel por operador).</div>
    </div>
    <div id="perf-history-list" style="margin-top:10px;"></div>
  </div>
</div>

                    <input type="date" id="perf-date-filter" onchange="loadPerformanceStats()" style="width:220px;">
                </div>
                <div class="scroll-area"><table id="perf-table"><thead><tr><th>Operator</th><th>Packed</th><th>Returns</th><th>Pre-Packs</th><th>Total</th></tr></thead><tbody></tbody></table></div>
            </div>
        </div>

        <!-- SECTION: REPORTS (EXCEL EXPORT) -->
        <div id="sec-reports" class="section">
            <div class="card">
                <h2>üìÅ Excel Reports & Exports</h2>
                <div class="grid-2">
                    <div>
                        <h4>1. Export by Date Range</h4>
                        <label>Start Date:</label><input type="date" id="rep-start-date">
                        <label>End Date:</label><input type="date" id="rep-end-date">
                        <div style="display:grid; grid-template-columns: 1fr 1fr; gap:10px;">
                            <button class="btn-mobile-op btn-op-green" onclick="exportData('ACTIVITY')">Packing/Returns</button>
                            <button class="btn-mobile-op btn-op-green" style="background:var(--color-prepack);" onclick="exportData('PREPACK')">Pre-Packing</button>
                        </div>
                    </div>
                    <div>
                        <h4>2. Transport Carrier Report</h4>
                        <p>Export ID | Carrier | Timestamps list.</p>
                        <button class="btn-mobile-op btn-op-purple" style="width:100%;" onclick="exportData('CARRIERS')">Group by Carrier</button>
                        <small>* Start/End/Confirmed times included.</small>
                    </div>
                </div>
            </div>
        </div>

        
        <!-- SECTION: CROSSCHECK (PACKED vs RETURNS) -->
        <div id="sec-cross" class="section">
            <div class="card">
                <h2>Crosscheck: PACKED vs RETURNS</h2>
                <p style="margin-top:6px; color:#666;">
                    Cruza IDs que foram <b>PACKED</b> (sa√≠ram) com IDs em <b>RETURNS</b> (voltaram) e compara as picagens de produtos.
                </p>

                <div class="grid-2" style="margin-top:14px;">
                    <div>
                        <label>Start date</label>
                        <input type="date" id="cross-start" />
                    </div>
                    <div>
                        <label>End date</label>
                        <input type="date" id="cross-end" />
                    </div>
                </div>

                <div style="display:flex; gap:14px; flex-wrap:wrap; align-items:center; margin-top:12px;">
                    <label style="display:flex; align-items:center; gap:6px;">
                        <input type="checkbox" id="cross-only-returned" checked />
                        S√≥ IDs que voltaram
                    </label>
                    <label style="display:flex; align-items:center; gap:6px;">
                        <input type="checkbox" id="cross-only-mismatch" />
                        S√≥ com diferen√ßas (itens)
                    </label>
                    <button class="btn-submit" onclick="runCrosscheck()">RUN</button>
                    <button class="btn-secondary" onclick="exportCrosscheck()">EXPORT XLSX</button>
                    <span id="cross-status" style="color:#777;"></span>
                </div>
            </div>

            <div class="card" style="margin-top:14px;">
                <div id="cross-summary" style="display:flex; gap:18px; flex-wrap:wrap;"></div>
                <div style="overflow:auto; margin-top:10px;">
                    <table class="table" id="cross-table">
                        <thead>
                            <tr>
                                <th>ID</th>
                                <th>Packed At</th>
                                <th>Returned At</th>
                                <th>Packed Items</th>
                                <th>Returned Items</th>
                                <th>Missing (Packed ‚Üí Returns)</th>
                                <th>Extra (Returns ‚Üí Packed)</th>
                                <th>Details</th>
                            </tr>
                        </thead>
                        <tbody></tbody>
                    </table>
                </div>
            </div>
        </div>

<!-- SECTION: PICKING -->
        <div id="sec-picking" class="section">
            <div class="card">
                <h2>üß∫ Picking Phase</h2>
                <div style="display:flex; gap:15px;">
                    <select id="pick-batch-select" onchange="loadPickingList()" style="flex:1; height:65px; font-size:22px; font-weight:bold;"></select>
                    <button id="btn-pick-details" class="btn-submit" style="width:200px; background:var(--primary); display:none;" onclick="openEditModal(document.getElementById('pick-batch-select').value, true)">VIEW DETAILS</button>
                    <button id="btn-select-all" class="btn-submit" style="width:200px; background:var(--accent); display:none;" onclick="selectAllPicking()">SELECT ALL</button>
                </div>
                <div id="picking-list-container" style="margin-top:25px;"></div>
                <button id="btn-finish-picking" class="btn-submit" style="background:var(--picking); display:none; margin-top:35px; height:80px; font-size:24px;" onclick="finishPicking()">PICKING COMPLETE -> MOVE TO PACKING</button>
            </div>
        </div>

        <!-- SECTION: PACKING -->
        <div id="sec-warehouse" class="section">
            <div class="grid-2">
                <div class="card">
                    <h3>1. Select Active Batch</h3>
                    <select id="wh-batch-select" onchange="loadBatchData(this.value)" style="height:70px; font-weight:bold; font-size:22px; border: 3px solid var(--primary);"></select>
                </div>
                <div class="card">
                    <div id="meta-cancel-banner" class="meta-cancel-banner" style="display:none;">
                        <span>ORDER CANCELED!</span>
                        <button class="btn-dismiss" onclick="resetScan()">CLEAR SCAN</button>
                    </div>
                    <p style="font-size:20px;">ID: <b id="v-id">-</b> | Track: <b id="v-track">-</b></p>
                    <div id="packing-info-display" style="display:none; border:2px solid #ddd; padding:15px; border-radius:10px; background:#fcfcfc;">
                        <div style="font-size:10px; font-weight:bold; color:#777;">CUSTOMER:</div> <div id="meta-cust-name" style="font-size:20px; font-weight:bold;">-</div>
                        <div style="font-size:10px; font-weight:bold; color:#777;">EXPECTED CONTENT:</div> <div id="meta-inv-content" style="font-size:20px; font-weight:bold; color:var(--accent);">-</div>
                    </div>
                    <div id="v-prods" style="display:flex; flex-wrap:wrap; gap:5px; margin-top:10px;"></div>
                </div>
            </div>
            <div class="card scan-area" style="text-align:center;">
                <input type="text" id="main-input" placeholder="SCAN BARCODE..." style="font-size:45px; text-align:center; height:100px; border: 4px solid var(--accent); border-radius:15px;" autocomplete="off">
                <button id="btn-confirm-order" class="btn-mobile-op btn-op-green" style="display:none;" onclick="confirmOrder('PACKING')">ID COMPLETE</button>
            </div>
            <div class="card">
                <h3>üì¶ IDs Picados neste Lote (Conclu√≠dos)</h3>
                <div class="scroll-area">
                    <table id="recent-scans-table">
                        <thead><tr><th>Hora</th><th>ID Pedido</th><th>Cliente</th><th>A√ß√µes</th></tr></thead>
                        <tbody></tbody>
                    </table>
                </div>
                <button id="btn-finalize-batch" class="btn-mobile-op btn-op-purple" style="display:none; margin-top:20px;" onclick="finishBatchPacking()">FINALIZE BATCH</button>
            </div>
        </div>

        <!-- SECTION: RETURNS -->
        <div id="sec-returns" class="section">
            <div class="card scan-area" style="text-align:center;">
                <h2>üîÑ RETURNS SCANNER</h2>
                <input type="text" id="return-input" placeholder="SCAN ID, TRACK OR PRODUCT..." style="font-size:45px; text-align:center; height:100px; border: 4px solid var(--returns); border-radius:15px;" autocomplete="off" onkeypress="if(event.key==='Enter'){handleScan(this.value, 'RETURN'); this.value='';}">
            </div>
            <div class="card">
                <p style="font-size:22px;">ID: <b id="rv-id">-</b> | Track: <b id="rv-track">-</b></p>
                <div id="rv-prods" style="display:flex; flex-wrap:wrap; gap:10px; margin-bottom:15px;"></div>
                <button class="btn-mobile-op btn-op-orange" onclick="confirmOrder('RETURN')">SAVE RETURN</button>
            </div>
            <div class="card">
                <h3>Recent Returns</h3>
                <div class="scroll-area"><table id="recent-returns-table"><thead><tr><th>Time</th><th>ID</th><th>Items</th><th>Action</th></tr></thead><tbody></tbody></table></div>
            </div>
        </div>

        <!-- OTHERS -->
        <div id="sec-prepack" class="section">
            <div class="card" style="text-align:center;"><h2>üì¶ PRE-PACKING</h2><input type="text" id="prepack-input" placeholder="SCAN..." style="font-size:45px; text-align:center; height:100px; border: 4px solid var(--color-prepack); border-radius:15px;" onkeypress="if(event.key==='Enter'){handlePrePack(this.value); this.value='';}"></div>
            <div class="card"><h3>Today's Pre-Packings</h3><div class="scroll-area"><table id="prepack-recent-table"><thead><tr><th>Time</th><th>Product</th><th>Action</th></tr></thead><tbody></tbody></table></div></div>
        </div>
        
<div id="sec-masterdata" class="section">
  <div class="card">
    <h2>üìã Master Product Database</h2>
    <div style="font-size:13px; color:#555; margin-top:6px;">
      Upload de CSV com <b>Coluna A = Nome do Produto</b> e <b>Coluna B = C√≥digo de Barras</b>.
      O mesmo produto pode ter v√°rios c√≥digos (cada barcode ‚Üí nome).
    </div>

    <div class="grid-2" style="margin-top:12px;">
      <div>
        <label style="font-weight:900;">Pesquisar</label>
        <input id="master-search" placeholder="Pesquisar por nome ou barcode..." style="width:100%; padding:10px; border-radius:10px; border:1px solid #ddd;" oninput="try{updateMasterPreview();}catch(e){}" onkeyup="try{updateMasterPreview();}catch(e){}">
        <div style="font-size:12px; color:#666; margin-top:6px;">A tabela atualiza automaticamente.</div>
      </div>
      <div>
        <label style="font-weight:900;">Upload CSV</label>
        <input type="file" id="csv-file-input" accept=".csv,text/csv" style="width:100%; padding:10px; border-radius:10px; border:1px solid #ddd; background:#fff;">
        <div style="display:flex; gap:10px; flex-wrap:wrap; margin-top:10px;">
          <button class="btn-submit" onclick="handleCSVUpload()">UPLOAD CSV</button>
          <button class="btn-submit" style="background:#0ea5e9; color:white;" onclick="exportMasterDB && exportMasterDB()">EXPORTAR CSV</button>
        </div>
        <div id="master-upload-status" style="margin-top:8px; font-size:12px; color:#666;"></div>
      </div>
    </div>

    <div class="table-area" style="margin-top:14px; overflow:auto;">
      <table id="master-db-table" style="width:100%; border-collapse:collapse;">
        <thead>
          <tr style="text-align:left;">
            <th style="padding:8px; border-bottom:1px solid #eee;">Barcode</th>
            <th style="padding:8px; border-bottom:1px solid #eee;">Product Name</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>
</div>

<div id="sec-office" class="section">
  <div class="card">
    <h2>üì¶ Create New Batch</h2>

    <div class="grid-2">
      <input type="text" id="off-batch-name" placeholder="Name">
      <select id="off-carrier-select"></select>
    </div>

    <input type="date" id="off-batch-date">

    <div class="grid-2">
      <textarea id="off-products-list" rows="12" placeholder="SKU [TAB] Qty [TAB] Pos"></textarea>
      <textarea id="off-order-meta" rows="12" placeholder="ID [TAB] Customer [TAB] Content"></textarea>
    </div>

    <button class="btn-submit" onclick="createBatch()">CREATE BATCH</button>

    <hr style="margin:30px 0;">

    <h3>üöö Gerir Transportadoras</h3>

    <div class="grid-2">
      <input type="text" id="new-carrier-input" placeholder="Nova transportadora (ex: DHL)">
      <button class="btn-submit" onclick="addCarrier()">ADICIONAR</button>
    </div>

    <div id="carrier-admin-list" style="margin-top:15px;"></div>
  </div>
</div>
    </div>
</div>

<script>
    const firebaseConfig = {
        apiKey: "AIzaSyDExvgmtrSILCATQgE8ICJX-SVntb5lM2Y",
        authDomain: "wh-murtede.firebaseapp.com",
        databaseURL: "https://wh-murtede-default-rtdb.europe-west1.firebasedatabase.app",
        projectId: "wh-murtede",
        storageBucket: "wh-murtede.firebasestorage.app",
        messagingSenderId: "415946575714",
        appId: "1:415946575714:web:b1516b91b9735b9248e63b"
    };
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth(), db = firebase.database();

    // scanData now includes startTime and endTime
    let currentUser = null, scanData = { id: "", track: "", prods: [], startTime: "", endTime: "", startTs: null, endTs: null };
    let isAdminUser = false;
    let masterProductsDB = {}, currentMode = "PACKING", activeBatchData = null, activeBatchPath = null;

    function safeKey(str) { if(!str) return "UNKNOWN"; return str.toString().replace(/[.#$/[\]]/g, "_").trim().toUpperCase(); }

    

    // Returns expected IDs excluding cancelled IDs
    function getRequiredBatchIds(batch) {
        const expected = (batch && batch.expected_ids) ? batch.expected_ids : [];
        const cancelled = (batch && batch.cancelled_ids) ? Object.keys(batch.cancelled_ids) : [];
        const cancelledSet = new Set(cancelled);
        return expected.filter(id => !cancelledSet.has(id));
    }

document.addEventListener('click', (e) => {
        const inp = document.getElementById('main-input');
        if (inp && !['INPUT','TEXTAREA','SELECT','OPTION','BUTTON'].includes(e.target.tagName) && !e.target.closest('.modal-content')) { inp.focus(); }
    });

    window.onload = () => { 
        const today = new Date().toISOString().split('T')[0];
        document.querySelectorAll('input[type="date"]').forEach(i => i.value = today);
    
        try {
            var todayObj = new Date();
            var end = todayObj.toISOString().split('T')[0];
            var startObj = new Date(todayObj.getTime() - (7 * 24 * 60 * 60 * 1000));
            var start = startObj.toISOString().split('T')[0];
            var sEl = document.getElementById('search-start-date');
            var eEl = document.getElementById('search-end-date');
            if (sEl) sEl.value = start;
            if (eEl) eEl.value = end;
        } catch(e) {}
};

    auth.onAuthStateChanged(user => {
        if (user) { currentUser = user; setupUI(user.email); } 
        else { document.getElementById('login-screen').style.display = 'flex'; document.getElementById('main-interface').style.display = 'none'; }
    });

    async function handleLogin() {
        const e = document.getElementById('login-email').value, p = document.getElementById('login-pass').value;
        try { await auth.signInWithEmailAndPassword(e, p); } catch(e) { alert("Invalid credentials."); }
    }

    function setupUI(email) {
        document.getElementById('login-screen').style.display = 'none';
        document.getElementById('main-interface').style.display = 'block';
        const isAdmin = email.endsWith('@admin.com');
        isAdminUser = isAdmin;
        const m = document.getElementById('menu-items');
        
        m.innerHTML = isAdmin ? 
            `<div class="nav-item" onclick="tab('sec-overview', this)">OVERVIEW</div>
             <div class="nav-item" onclick="tab('sec-search', this)">SEARCH</div>
             <div class="nav-item" onclick="tab('sec-performance', this)">PERFORMANCE</div>
             <div class="nav-item" onclick="tab('sec-reports', this)">REPORTS</div>
             <div class="nav-item" onclick="tab('sec-cross', this)">CROSSCHECK</div>
             <div class="nav-item" onclick="tab('sec-prepack', this)">PRE-PACKING</div>
             <div class="nav-item" onclick="tab('sec-masterdata', this)">MASTER DATA</div>
             <div class="nav-item" onclick="tab('sec-office', this)">OFFICE</div>
             <div class="nav-item" onclick="tab('sec-picking', this)">PICKING</div>
             <div class="nav-item" onclick="tab('sec-warehouse', this)">PACKING</div>
             <div class="nav-item" onclick="tab('sec-returns', this)">RETURNS</div>` :
            `<div class="nav-item" onclick="tab('sec-picking', this)">PICKING</div>
             <div class="nav-item" onclick="tab('sec-prepack', this)">PRE-PACKING</div>
             <div class="nav-item" onclick="tab('sec-returns', this)">RETURNS</div>
             <div class="nav-item" onclick="tab('sec-warehouse', this)">PACKING</div>`;

        // Default Overview day to today (Overview is realtime by default)
        const df = document.getElementById('global-date-filter');
        if(df && !df.value) df.value = _todayDateClean();

        // Wire single-instance listeners (active_batches + config)
        initRealtimeCore();

        // Open initial tab (tab() will set _currentSection and render Overview if needed)
        if(isAdmin) tab('sec-overview', document.querySelector('[onclick*="sec-overview"]'));
        else tab('sec-picking', document.querySelector('[onclick*="sec-picking"]'));
    }

    function tab(id, el) {
        // --- ACCESS GUARD (WH users only see Picking, Pre-Packing, Returns, Packing) ---
        if(!isAdminUser) {
            const allowed = ['sec-picking','sec-prepack','sec-returns','sec-warehouse'];
            if(!allowed.includes(id)) {
                id = 'sec-picking';
                el = document.querySelector('[onclick*="sec-picking"]');
            }
        }

        _currentSection = id;

        document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
        document.querySelectorAll('.nav-item').forEach(i => i.classList.remove('active'));
        document.getElementById(id).classList.add('active');
        if(el) el.classList.add('active');
        
        if(id === 'sec-warehouse') {
            const saved = localStorage.getItem('lastPackingBatch');
            if(saved) { setTimeout(() => { const sel = document.getElementById('wh-batch-select'); if(sel && sel.querySelector(`option[value="${saved}"]`)) { sel.value = saved; loadBatchData(saved); } }, 300); }
        }
        resetScan();
        if(id === 'sec-prepack') loadPrePackHistory();
        if(id === 'sec-returns') loadRecentReturns();
        if(id === 'sec-masterdata') setTimeout(() => { try{ updateMasterPreview(); }catch(e){} }, 150);

        // Overview: realtime only for today; old days only when user changes the date
        if(id === 'sec-overview') {
            syncGlobalData();
        } else {
            // Leaving overview => drop its realtime listener to keep mobile light
            stopPrepackCardListener();
        }
}

    function logout() { auth.signOut(); localStorage.removeItem('lastPackingBatch'); }

    // --- NEW: EXCEL EXPORT LOGIC WITH START/END TIMES ---
    async function exportData(type) {
        const start = document.getElementById('rep-start-date').value;
        const end = document.getElementById('rep-end-date').value;
        const dataToExport = [];

        // Helper: check YYYY-MM-DD in range (inclusive)
        const inRange = (d) => (d && d >= start && d <= end);

        if (type === 'ACTIVITY') {
            const snap = await db.ref('registos').once('value');
            const batchSnap = await db.ref('active_batches').once('value');
            const batches = batchSnap.val() || {};

            Object.values(snap.val() || {}).forEach(r => {
                if (inRange(r.dateClean)) {
                    const carrier = (batches[r.batch] && batches[r.batch].carrier) ? batches[r.batch].carrier : "N/A";
                    dataToExport.push({
                        Date: r.dateClean,
                        Start_Time: r.startTime || r.time,
                        End_Time: r.endTime || r.time,
                        ID: r.id,
                        Mode: r.mode,
                        User: r.user,
                        Tracking: r.track,
                        Items: r.prods,
                        Carrier: carrier,
                        Batch_Key: r.batch || "GENERAL",
                        Batch_Name: (batches[r.batch] && batches[r.batch].name) ? batches[r.batch].name : "GENERAL"
                    });
                }
            });

        } else if (type === 'CARRIERS') {
            // CARRIERS: export ALL IDs created in batches in the date range,
            // including batch info, who packed, tracking, contents, status + cancellation reason.
            const [batchSnap, regSnap] = await Promise.all([
                db.ref('active_batches').once('value'),
                db.ref('registos').once('value')
            ]);

            const batches = batchSnap.val() || {};
            const registos = regSnap.val() || {};

            // Build quick lookup for packing records: batchKey -> id -> latest packing record
            const packIndex = {};
            Object.values(registos).forEach(r => {
                if (r && r.mode === 'PACKING' && r.batch && r.id) {
                    if (!packIndex[r.batch]) packIndex[r.batch] = {};
                    const prev = packIndex[r.batch][r.id];
                    // pick the latest by (dateClean + time) string if possible; else keep first
                    const curKey = (r.dateClean || "") + " " + (r.endTime || r.time || "");
                    const prevKey = prev ? ((prev.dateClean || "") + " " + (prev.endTime || prev.time || "")) : "";
                    if (!prev || curKey > prevKey) packIndex[r.batch][r.id] = r;
                }
            });

            Object.entries(batches).forEach(([batchKey, b]) => {
                if (!b || !inRange(b.dateClean)) return;

                const batchName = b.name || batchKey;
                const carrier = b.carrier || "N/A";
                const expected = b.expected_ids || [];
                const orderDetails = b.order_details || {};
                const cancelled = b.cancelled_ids || {};

                expected.forEach(orderId => {
                    const det = orderDetails[orderId] || {};
                    const cancelInfo = cancelled[orderId] || null;
                    const packRec = (packIndex[batchKey] && packIndex[batchKey][orderId]) ? packIndex[batchKey][orderId] : null;

                    // Status precedence: CANCELLED > PACKED > PENDING
                    let status = "PENDING";
                    if (cancelInfo) status = "CANCELLED";
                    else if (packRec) status = "PACKED";

                    dataToExport.push({
                        Batch_Key: batchKey,
                        Batch_Name: batchName,
                        Carrier: carrier,
                        Batch_Date: b.dateClean || "",
                        Order_ID: orderId,
                        Customer: det.name || "",
                        Expected_Content: det.content || "",
                        Status: status,
                        Cancel_Reason: cancelInfo ? (cancelInfo.reason || "") : "",
                        Cancelled_By: cancelInfo ? (cancelInfo.user || "") : "",
                        Cancelled_At: cancelInfo ? (cancelInfo.DateTime || cancelInfo.time || "") : "",
                        Packed_By: packRec ? (packRec.user || "") : "",
                        Packed_Date: packRec ? (packRec.dateClean || "") : "",
                        Packed_Start_Time: packRec ? (packRec.startTime || "") : "",
                        Packed_Confirmed_Time: packRec ? (packRec.endTime || packRec.time || "") : "",
                        Tracking: packRec ? (packRec.track || "") : "",
                        Packed_Items: packRec ? (packRec.prods || "") : ""
                    });
                });
            });

        } else if (type === 'PREPACK') {
            const snap = await db.ref('pre_packing').once('value');
            Object.values(snap.val() || {}).forEach(p => {
                if (inRange(p.dateClean)) {
                    dataToExport.push({ Date: p.dateClean, Time: p.time, User: p.user, Product: p.product });
                }
            });
        }

        if (dataToExport.length === 0) return alert("No data found for these dates.");
        const ws = XLSX.utils.json_to_sheet(dataToExport);
        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, ws, "Report");
        XLSX.writeFile(wb, `WH_Export_${type}_${start}_to_${end}.xlsx`);
    }

    // =========================
    // CROSSCHECK (PACKED vs RETURNS)
    // =========================
    let lastCrossRows = [];

    function _escapeHtml(s){
        return String(s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;');
    }


    function _normTime(t) {
        if(!t) return "00:00:00";
        t = String(t).trim();
        // Accept "HH:mm" -> add seconds
        if(/^\d{2}:\d{2}$/.test(t)) return t + ":00";
        // Accept "HH:mm:ss"
        if(/^\d{2}:\d{2}:\d{2}$/.test(t)) return t;
        // Some locales might include seconds already; fallback: take first 8 chars if it resembles time
        if(t.length >= 8 && /^\d{2}:\d{2}:\d{2}/.test(t)) return t.slice(0,8);
        return "00:00:00";
    }

    function _splitItems(prodsStr) {
        if(!prodsStr) return [];
        const s = String(prodsStr).trim();
        if(!s || s === "No Items") return [];
        return s.split('|').map(x => x.trim()).filter(Boolean);
    }

    function _countItems(items) {
        const m = {};
        items.forEach(it => { m[it] = (m[it] || 0) + 1; });
        return m;
    }

    function _diffCounts(packedCounts, returnsCounts) {
        const missing = [];
        const extra = [];
        Object.keys(packedCounts).forEach(k => {
            const d = packedCounts[k] - (returnsCounts[k] || 0);
            if(d > 0) missing.push(`${k} x${d}`);
        });
        Object.keys(returnsCounts).forEach(k => {
            const d = returnsCounts[k] - (packedCounts[k] || 0);
            if(d > 0) extra.push(`${k} x${d}`);
        });
        return { missing, extra };
    }

    function _tsFrom(dc, tm) {
        if(!dc) return 0;
        const t = _normTime(tm);
        const ms = new Date(`${dc}T${t}`).getTime();
        return Number.isFinite(ms) ? ms : 0;
    }

    async function runCrosscheck() {
        const statusEl = document.getElementById('cross-status');
        const tbody = document.querySelector('#cross-table tbody');
        const summaryEl = document.getElementById('cross-summary');

        const start = document.getElementById('cross-start').value;
        const end = document.getElementById('cross-end').value;
        const onlyReturned = document.getElementById('cross-only-returned').checked;
        const onlyMismatch = document.getElementById('cross-only-mismatch').checked;

        statusEl.textContent = "Loading...";
        tbody.innerHTML = "";
        summaryEl.innerHTML = "";
        lastCrossRows = [];

        try {
            let ref = db.ref('registos').orderByChild('dateClean');
            if(start) ref = ref.startAt(start);
            if(end) ref = ref.endAt(end);

            const snap = await ref.once('value');
            const data = snap.val() || {};

            // per-id buckets
            const perId = {}; // { [id]: { packed:[], returns:[] } }

            Object.keys(data).forEach(k => {
                const r = data[k];
                if(!r || !r.id) return;
                const modeRaw = (r.mode || r.Type || "").toString().trim().toUpperCase();
                const isPacking = (modeRaw === "PACKING" || modeRaw === "PACKED");
                const isReturn  = (modeRaw === "RETURNS" || modeRaw === "RETURN" || modeRaw === "RETURNED");
                if(!isPacking && !isReturn) return;
                const mode = isPacking ? "PACKING" : "RETURNS";

                const id = String(r.id).trim();
                if(!perId[id]) perId[id] = { packed: [], returns: [] };

                const dc = r.dateClean || "";
                const tm = _normTime(r.endTime || r.time || r.startTime);
                const ts = (r.ts && Number.isFinite(r.ts)) ? r.ts : _tsFrom(dc, tm);
                const dt = r.DateTime || (dc ? _dt(dc, tm) : "");
                const items = _splitItems(r.prods);

                const entry = {
                    id,
                    mode,
                    batch: r.batch || "GENERAL",
                    user: r.user || "",
                    track: r.track || r.tracking || "",
                    dateClean: dc,
                    time: tm,
                    DateTime: dt,
                    ts: ts,
                    prodsStr: r.prods || "",
                    items: items
                };

                if(mode === "PACKING") perId[id].packed.push(entry);
                else perId[id].returns.push(entry);
            });

            // Reduce per-id to latest packed + latest return after packed
            const rows = [];
            let packedIds = 0, returnedIds = 0, mismatchIds = 0;

            Object.keys(perId).forEach(id => {
                const b = perId[id];
                if(!b.packed.length) return; // only consider IDs that "sa√≠ram"

                packedIds += 1;

                const packedLatest = b.packed.sort((a,b)=> (a.ts||0)-(b.ts||0)).slice(-1)[0];
                const returnsAfter = b.returns.filter(x => (x.ts||0) > (packedLatest.ts||0));
                const returnedLatest = returnsAfter.sort((a,b)=> (a.ts||0)-(b.ts||0)).slice(-1)[0];

                const returned = !!returnedLatest;
                if(onlyReturned && !returned) return;

                const packedItems = packedLatest.items;
                const returnItems = returnedLatest ? returnedLatest.items : [];

                const packedCounts = _countItems(packedItems);
                const returnCounts = _countItems(returnItems);
                const diff = _diffCounts(packedCounts, returnCounts);

                const hasMismatch = (diff.missing.length || diff.extra.length);
                if(onlyMismatch && !hasMismatch) return;

                if(returned) returnedIds += 1;
                if(hasMismatch) mismatchIds += 1;

                rows.push({
                    id,
                    packedAt: packedLatest.DateTime || _dt(packedLatest.dateClean, packedLatest.time),
                    returnedAt: returnedLatest ? (returnedLatest.DateTime || _dt(returnedLatest.dateClean, returnedLatest.time)) : "",
                    packedCount: packedItems.length,
                    returnCount: returnItems.length,
                    missing: diff.missing,
                    extra: diff.extra,
                    packed: packedLatest,
                    returned: returnedLatest
                });
            });

            // Sort: most recent packed first
            rows.sort((a,b)=> (_tsFrom(a.packed.dateClean, a.packed.time) - _tsFrom(b.packed.dateClean, b.packed.time)));

            // Render summary
            summaryEl.innerHTML = `
                <div><b>Packed IDs</b>: ${packedIds}</div>
                <div><b>Returned</b>: ${returnedIds}</div>
                <div><b>Not returned</b>: ${Math.max(0, packedIds - returnedIds)}</div>
                <div><b>Mismatches</b>: ${mismatchIds}</div>
                <div style="color:#777;">(Filtro aplicado: ${onlyReturned ? "returned only" : "all packed"}, ${onlyMismatch ? "mismatch only" : "all"})</div>
            `;

            // Render table
            tbody.innerHTML = rows.map(r => {
                const miss = r.missing.length ? r.missing.join('<br>') : "-";
                const extra = r.extra.length ? r.extra.join('<br>') : "-";
                const packedList = r.packed.items.length ? r.packed.items.map(x=>`‚Ä¢ ${_escapeHtml(x)}`).join('<br>') : "(none)";
                const returnList = (r.returned && r.returned.items.length) ? r.returned.items.map(x=>`‚Ä¢ ${_escapeHtml(x)}`).join('<br>') : "(none)";
                const det = `
                  <details>
                    <summary>View</summary>
                    <div style="margin-top:6px;">
                      <div style="font-weight:bold; margin-bottom:4px;">PACKED</div>
                      <div style="font-size:12px; color:#555;">${packedList}</div>
                      <div style="font-weight:bold; margin:10px 0 4px;">RETURNS</div>
                      <div style="font-size:12px; color:#555;">${returnList}</div>
                    </div>
                  </details>`;
                return `<tr>
                    <td>${_escapeHtml(r.id)}</td>
                    <td>${_escapeHtml(r.packedAt || "")}</td>
                    <td>${_escapeHtml(r.returnedAt || "")}</td>
                    <td style="text-align:center;">${r.packedCount}</td>
                    <td style="text-align:center;">${r.returnCount}</td>
                    <td style="font-size:12px;">${miss}</td>
                    <td style="font-size:12px;">${extra}</td>
                    <td>${det}</td>
                </tr>`;
            }).join("");

            lastCrossRows = rows;
            statusEl.textContent = `Done (${rows.length} rows).`;
        } catch (e) {
            console.error(e);
            statusEl.textContent = "";
            alert("Erro no crosscheck.");
        }
    }

    function exportCrosscheck() {
        if(!lastCrossRows || !lastCrossRows.length) return alert("Sem dados para exportar. Corre primeiro o RUN.");
        const out = lastCrossRows.map(r => ({
            ID: r.id,
            Packed_At: r.packedAt,
            Returned_At: r.returnedAt,
            Packed_Items: r.packedCount,
            Returned_Items: r.returnCount,
            Missing: r.missing.join(" | "),
            Extra: r.extra.join(" | "),
            Packed_Batch: (r.packed && r.packed.batch) ? r.packed.batch : "",
            Returns_Batch: (r.returned && r.returned.batch) ? r.returned.batch : "",
            Packed_Tracking: (r.packed && r.packed.track) ? r.packed.track : "",
            Returns_Tracking: (r.returned && r.returned.track) ? r.returned.track : ""
        }));

        const ws = XLSX.utils.json_to_sheet(out);
        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, ws, "Crosscheck");
        const s = document.getElementById('cross-start').value || "ALL";
        const e = document.getElementById('cross-end').value || "ALL";
        XLSX.writeFile(wb, `WH_Crosscheck_PACKED_vs_RETURNS_${s}_to_${e}.xlsx`);
    }
function handleScan(v, mode) {
        const m = mode || currentMode;
        const key = safeKey(v);
        if(masterProductsDB[key]) {
            const prodName = masterProductsDB[key]; scanData.prods.push(prodName);
        } else if(/^\d{8}$/.test(v)) {
            // RECORD START TIME ON FIRST SCAN OF ID
            if(!scanData.id){ scanData.startTime = _nowTime(); scanData.startTs = Date.now(); }
            scanData.id = v; if(m === 'PACKING') showMetadata(v); 
        } else {
            scanData.track = v;
        }
        updateDisplay(m);
        if(scanData.id && scanData.track) document.getElementById('btn-confirm-order').style.display = 'block';
    }

    async function confirmOrder(mode) {
        const m = mode || currentMode;
        const bId = document.getElementById('wh-batch-select').value;

        // Guard: allow viewing old/COMPLETED batches, but block writing packing records
        if(m === 'PACKING' && activeBatchData && activeBatchData.status && activeBatchData.status !== 'READY_TO_PACK') {
            return alert("Este lote est√° fechado (COMPLETED) ou ainda n√£o est√° pronto para packing.");
        }
        if(!scanData.id || !scanData.track) return alert("Faltam dados!");

        const endTime = _nowTime();
        const endTs = Date.now();

        try {
            if(m === 'PACKING' && bId) {
                await db.ref(`active_batches/${bId}/processed_ids/${scanData.id}`).set(true);
                logBatchAction(bId, `PACKED ID: ${scanData.id}`);
            }
            await db.ref('registos').push({ 
                id: scanData.id, 
                track: scanData.track, 
                prods: scanData.prods.join(' | ') || "No Items", 
                mode: m, 
                batch: bId || "GENERAL", 
                user: currentUser.email.split('@')[0].toUpperCase(), 
                startTime: scanData.startTime || "",
                endTime: endTime,
                startTs: (typeof scanData.startTs === 'number') ? scanData.startTs : null,
                endTs: endTs,
                time: endTime, // Main sorting time
                dateClean: new Date().toISOString().split('T')[0]
            });

            // NEW: write to persistent ID history so SEARCH can show all events even across batch recreations
            const dc = new Date().toISOString().split('T')[0];
            const uname = (currentUser && currentUser.email) ? currentUser.email.split('@')[0].toUpperCase() : "UNKNOWN";
            const bKey = bId || "GENERAL";
            const bName = (m === 'PACKING' && activeBatchData && activeBatchData.name) ? activeBatchData.name : bKey;
            const carr = (m === 'PACKING' && activeBatchData && activeBatchData.carrier) ? activeBatchData.carrier : "N/A";
            await pushIdHistory(scanData.id, {
                Type: (m === 'PACKING') ? "PACKING" : "RETURNS",
                BatchKey: bKey,
                Batch: bName,
                Carrier: carr,
                User: uname,
                dateClean: dc,
                time: endTime,
                Tracking: scanData.track,
                Items_or_Content: scanData.prods.join(' | ') || "No Items",
                Details: (m === 'PACKING')
                    ? ("Start: " + (scanData.startTime || endTime) + " | Confirm: " + endTime)
                    : "Return saved"
            });

            resetScan(); 
        } catch (e) { alert("Erro ao gravar."); }
    }

    function resetScan() {
        scanData = {id:"", track:"", prods:[], startTime: "", endTime: "", startTs: null, endTs: null}; 
        const labels = ['v-id', 'v-track', 'meta-cust-name', 'meta-inv-content', 'rv-id', 'rv-track'];
        labels.forEach(id => { const el = document.getElementById(id); if(el) el.innerText = "-"; });
        const containers = ['v-prods', 'rv-prods'];
        containers.forEach(id => { const el = document.getElementById(id); if(el) el.innerHTML = ""; });
        document.getElementById('packing-info-display').style.display = 'none'; 
        document.getElementById('meta-cancel-banner').style.display = 'none'; 
        document.getElementById('btn-confirm-order').style.display = 'none'; 
        const inp = document.getElementById('main-input'); if(inp) { inp.value = ""; inp.focus(); }
    }

    // --- OTHER LOGICS ---
    // --- SEARCH: CARDS PER ID + MODAL FULL HISTORY + EXPORT (PERFORMANCE + FILTERS + TIMELINE) ---
    var searchCache = { ids: [], eventsById: {}, summaryById: {}, activeId: null };

    function _fmt(val) { return (val === undefined || val === null) ? "" : String(val); }

    function _dtKey(dateClean, timeStr) {
        return (_fmt(dateClean) + " " + _fmt(timeStr)).trim();
    }

    

    // Cache + helper to retrieve picking operator from registos when active_batches fields are not writable
    const _pickingInfoCache = {};
    async function getPickingInfo(batchId){
        if(!batchId) return null;
        if(_pickingInfoCache[batchId]) return _pickingInfoCache[batchId];
        try{
            const snap = await db.ref('registos').orderByChild('batch').equalTo(batchId).once('value');
            let best = null;
            Object.values(snap.val() || {}).forEach(r => {
                if(r && (r.mode === "PICKING" || r.msg === "PICKING COMPLETE")){
                    const ts = (typeof r.ts === 'number') ? r.ts : 0;
                    if(!best || ts > (best.ts||0)) best = r;
                }
            });
            if(best){
                _pickingInfoCache[batchId] = { pickedBy: best.user, pickedAt: best.DateTime || _dtKey(best.dateClean, best.time), ts: best.ts||0 };
                return _pickingInfoCache[batchId];
            }
        }catch(e){
            console.warn("getPickingInfo failed", e);
        }
        return null;
    }
function _parseIds(raw) {
        return raw.split(/[\s,]+/).map(function(x){ return x.trim(); }).filter(function(x){ return x !== ""; });
    }

    function _getSearchFilters() {
        var s = document.getElementById('search-start-date');
        var e = document.getElementById('search-end-date');
        var t = document.getElementById('search-type-filter');
        var st = document.getElementById('search-status-filter');

        return {
            start: s ? s.value : "",
            end: e ? e.value : "",
            type: t ? t.value : "ALL",
            status: st ? st.value : "ALL"
        };
    }

    function _passesType(typeVal, filterVal) {
        if (!filterVal || filterVal === "ALL") return true;
        return typeVal === filterVal;
    }

    function _passesDate(dt, start, end) {
        // dt format: "YYYY-MM-DD ..." or locale string; we use prefix compare when possible.
        if (!start && !end) return true;
        var d = _fmt(dt).slice(0, 10);
        if (start && d < start) return false;
        if (end && d > end) return false;
        return true;
    }

    function _renderTimeline(events) {
        var box = document.getElementById('id-history-timeline');
        if (!box) return;

        if (!events || !events.length) {
            box.innerHTML = "<div style='padding:12px; color:#666;'>No events for this filter.</div>";
            return;
        }

        var html = "<div style='position:relative; margin-left: 16px; border-left: 3px solid #e5e7eb; padding-left: 18px;'>";
        events.forEach(function(ev){
            var type = _fmt(ev.Type);
            var dot = "var(--accent)";
            if (type === "PACKING") dot = "var(--packing)";
            if (type === "RETURNS") dot = "var(--returns)";
            if (type === "CANCELLED") dot = "var(--error)";
            if (type.indexOf("OFFICE") === 0) dot = "var(--primary)";

            html += "<div style='position:relative; margin: 14px 0;'>";
            html += "<div style='position:absolute; left:-28px; top: 8px; width:14px; height:14px; border-radius:999px; background:" + dot + "; box-shadow:0 0 0 4px rgba(0,0,0,0.06);'></div>";
            html += "<div style='background:white; border:1px solid #eee; border-radius:14px; padding:12px 14px; box-shadow: 0 3px 10px rgba(0,0,0,0.04);'>";
            html += "<div style='display:flex; justify-content:space-between; gap:10px; align-items:center;'>";
            html += "<div style='font-weight:900;'>" + type + "</div>";
            html += "<div style='font-size:12px; color:#666;'>" + _fmt(ev.DateTime) + "</div>";
            html += "</div>";
            var meta = [];
            if (_fmt(ev.Batch)) meta.push("<b>Batch:</b> " + _fmt(ev.Batch));
            if (_fmt(ev.Carrier)) meta.push("<b>Carrier:</b> " + _fmt(ev.Carrier));
            if (_fmt(ev.User)) meta.push("<b>User:</b> " + _fmt(ev.User));
            if (_fmt(ev.Tracking)) meta.push("<b>Track:</b> " + _fmt(ev.Tracking));
            if (_fmt(ev.Items_or_Content)) meta.push("<b>Items:</b> " + _fmt(ev.Items_or_Content));
            if (meta.length) html += "<div style='margin-top:8px; font-size:13px; line-height:1.35;'>" + meta.join(" &nbsp; | &nbsp; ") + "</div>";
            if (_fmt(ev.Details)) html += "<div style='margin-top:8px; font-size:12px; color:#444;'><small>" + _fmt(ev.Details) + "</small></div>";
            html += "</div>";
            html += "</div>";
        });
        html += "</div>";
        box.innerHTML = html;
    }

    function _renderSearchCards() {
        var container = document.getElementById('search-cards-container');
        if (!container) return;
        container.innerHTML = "";

        if (!searchCache.ids || searchCache.ids.length === 0) {
            container.innerHTML = "<div class='card' style='grid-column: 1 / -1;'><b>No IDs.</b></div>";
            return;
        }

        var anyFound = false;
        var filters = _getSearchFilters();

        searchCache.ids.forEach(function(id){
            var s = searchCache.summaryById[id] || {};
            var events = searchCache.eventsById[id] || [];
            if (events.length > 0) anyFound = true;

            // apply status filter to cards (summary-based)
            var status = _fmt(s.status || (events.length ? "FOUND" : "NOT FOUND"));
            if (filters.status !== "ALL" && status !== filters.status) return;

            var last = _fmt(s.lastEvent || "");
            var batchName = _fmt(s.batchName || "");
            var carrier = _fmt(s.carrier || "");
            var cancelReason = _fmt(s.cancelReason || "");
            var packedBy = _fmt(s.packedBy || "");
            var tracking = _fmt(s.tracking || "");

            var badgeColor = (status === "CANCELLED") ? "var(--returns)" : (status === "PACKED" ? "var(--packing)" : (status === "PENDING" ? "var(--accent)" : "var(--primary)"));

            var card = document.createElement('div');
            card.className = "card";
            card.style.padding = "18px";

            var top = "<div style='display:flex; justify-content:space-between; align-items:center; gap:10px;'>"
                + "<div style='font-size:20px; font-weight:900;'>ID " + id + "</div>"
                + "<div style='background:" + badgeColor + "; color:white; padding:6px 10px; border-radius:10px; font-weight:900; font-size:12px;'>" + status + "</div>"
                + "</div>";

            var lines = "";
            if (batchName) lines += "<div style='margin-top:10px; font-size:14px;'><b>Batch:</b> " + batchName + "</div>";
            if (carrier) lines += "<div style='font-size:14px;'><b>Carrier:</b> " + carrier + "</div>";
            if (packedBy) lines += "<div style='font-size:14px;'><b>Packed by:</b> " + packedBy + "</div>";
            if (tracking) lines += "<div style='font-size:14px;'><b>Tracking:</b> " + tracking + "</div>";
            if (cancelReason) lines += "<div style='font-size:14px; color: var(--error);'><b>Cancel:</b> " + cancelReason + "</div>";
            if (last) lines += "<div style='margin-top:8px; font-size:12px; color:#666;'><b>Last event:</b> " + last + "</div>";

            var btns = "<div style='display:flex; gap:10px; margin-top:15px;'>"
                + "<button class='btn-small' style='background: var(--primary); flex:1; padding:12px;' onclick=\"openIdHistoryModal('" + id + "')\">OPEN HISTORY</button>"
                + "<button class='btn-small' style='background: var(--accent); padding:12px;' onclick=\"exportIdHistoryDirect('" + id + "')\">EXPORT</button>"
                + "</div>";

            card.innerHTML = top + lines + btns;
            container.appendChild(card);
        });

        if (!anyFound) {
            var note = document.createElement('div');
            note.className = "card";
            note.style.gridColumn = "1 / -1";
            note.innerHTML = "<b>No history found for the provided IDs (within filters).</b>";
            container.appendChild(note);
        }
    }

    function _fillModalFiltersFromSearch() {
        var f = _getSearchFilters();
        var ms = document.getElementById('modal-start-date');
        var me = document.getElementById('modal-end-date');
        var mt = document.getElementById('modal-type-filter');
        var mst = document.getElementById('modal-status-filter');
        if (ms) ms.value = f.start || "";
        if (me) me.value = f.end || "";
        if (mt) mt.value = f.type || "ALL";
        if (mst) mst.value = (f.status && f.status !== "NOT FOUND") ? f.status : "ALL";
    }

    function openIdHistoryModal(id) {
        searchCache.activeId = id;
        _fillModalFiltersFromSearch();

        var title = document.getElementById('id-history-title');
        if (title) title.innerText = "ID History - " + id;

        // Render initial with filters
        applyIdHistoryFilters();

        document.getElementById('id-history-modal').style.display = 'flex';
    }

    function applyIdHistoryFilters() {
        var id = searchCache.activeId;
        if (!id) return;

        var ms = document.getElementById('modal-start-date');
        var me = document.getElementById('modal-end-date');
        var mt = document.getElementById('modal-type-filter');
        var mst = document.getElementById('modal-status-filter');

        var start = ms ? ms.value : "";
        var end = me ? me.value : "";
        var typeF = mt ? mt.value : "ALL";
        var statusF = mst ? mst.value : "ALL";

        var summary = searchCache.summaryById[id] || {};
        var sumEl = document.getElementById('id-history-summary');
        if (sumEl) {
            var parts = [];
            if (summary.batchName) parts.push("<b>Batch:</b> " + _fmt(summary.batchName));
            if (summary.carrier) parts.push("<b>Carrier:</b> " + _fmt(summary.carrier));
            if (summary.customer) parts.push("<b>Customer:</b> " + _fmt(summary.customer));
            if (summary.expectedContent) parts.push("<b>Expected:</b> " + _fmt(summary.expectedContent));
            parts.push("<b>Status:</b> " + _fmt(summary.status || ""));
            if (summary.cancelReason) parts.push("<b>Cancel reason:</b> " + _fmt(summary.cancelReason) + " (" + _fmt(summary.cancelBy) + " @ " + _fmt(summary.cancelAt) + ")");
            if (summary.packedBy) parts.push("<b>Packed by:</b> " + _fmt(summary.packedBy) + " @ " + _fmt(summary.packedAt));
            if (summary.tracking) parts.push("<b>Tracking:</b> " + _fmt(summary.tracking));
            sumEl.innerHTML = parts.join(" &nbsp; | &nbsp; ") || "";
        }

        var allEvents = searchCache.eventsById[id] || [];
        var filtered = allEvents.filter(function(ev){
            if (!_passesDate(ev.DateTime, start, end)) return false;
            if (!_passesType(_fmt(ev.Type), typeF)) return false;
            // status filter in modal is summary-based; apply CANCELLED/PACKED to event types for usability
            if (statusF === "CANCELLED" && _fmt(ev.Type) !== "CANCELLED") return false;
            if (statusF === "PACKED" && _fmt(ev.Type) !== "PACKING") return false;
            if (statusF === "PENDING") {
                // Pending = show OFFICE created + (optional) returns, but exclude packed/cancel events
                if (_fmt(ev.Type) === "PACKING" || _fmt(ev.Type) === "CANCELLED") return false;
            }
            return true;
        });

        // Table
        var tbody = document.querySelector('#id-history-table tbody');
        if (tbody) tbody.innerHTML = "";
        filtered.forEach(function(ev){
            if (!tbody) return;
            tbody.innerHTML += "<tr" + ((_fmt(ev.Type) === "CANCELLED") ? " style='background:#fff0f0; border-left:6px solid var(--error);'" : "") + ">"
                + "<td>" + _fmt(ev.DateTime) + "</td>"
                + "<td><b style='" + ((_fmt(ev.Type) === "CANCELLED") ? "color:var(--error);" : "") + "'>" + _fmt(ev.Type) + "</b></td>"
                + "<td>" + _fmt(ev.Batch) + "</td>"
                + "<td>" + _fmt(ev.Carrier) + "</td>"
                + "<td>" + _fmt(ev.User) + "</td>"
                + "<td>" + _fmt(ev.Tracking) + "</td>"
                + "<td><small>" + _fmt(ev.Items_or_Content) + "</small></td>"
                + "<td><small style='" + ((_fmt(ev.Type) === "CANCELLED") ? "color:var(--error); font-weight:900;" : "") + "'>" + _fmt(ev.Details) + "</small></td>"
                + "</tr>";
        });

        // Timeline
        _renderTimeline(filtered);
    }

    function exportIdHistory() {
        if (!searchCache.activeId) return alert("No active ID.");
        exportIdHistoryDirect(searchCache.activeId);
    }

    function exportIdHistoryDirect(id) {
        var events = searchCache.eventsById[id] || [];
        if (!events.length) return alert("No history to export for this ID.");
        var ws = XLSX.utils.json_to_sheet(events);
        var wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, ws, "ID_History");
        var ts = new Date().toISOString().replace(/[:.]/g,'-');
        XLSX.writeFile(wb, "WH_ID_History_" + id + "_" + ts + ".xlsx");
    }

    function exportAllSearchHistories() {
        if (!searchCache.ids || searchCache.ids.length === 0) return alert("No IDs.");
        var all = [];
        searchCache.ids.forEach(function(id){
            var evs = searchCache.eventsById[id] || [];
            evs.forEach(function(e){
                var row = {};
                row.ID = id;
                row.DateTime = e.DateTime;
                row.Type = e.Type;
                row.Batch = e.Batch;
                row.Carrier = e.Carrier;
                row.User = e.User;
                row.Tracking = e.Tracking;
                row.Items_or_Content = e.Items_or_Content;
                row.Details = e.Details;
                all.push(row);
            });
        });
        if (!all.length) return alert("No history to export.");
        var ws = XLSX.utils.json_to_sheet(all);
        var wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, ws, "Search_All");
        var ts = new Date().toISOString().replace(/[:.]/g,'-');
        XLSX.writeFile(wb, "WH_Search_All_" + ts + ".xlsx");
    }

    async function searchOrderHistory() {
        var inputEl = document.getElementById('search-ids-input');
        var input = inputEl ? inputEl.value : "";
        if(!input.trim()) return alert("Enter IDs.");

        var idsToSearch = _parseIds(input);
        searchCache.ids = idsToSearch;
        searchCache.eventsById = {};
        searchCache.summaryById = {};
        searchCache.activeId = null;

        var container = document.getElementById('search-cards-container');
        if (container) container.innerHTML = "<div class='card' style='grid-column: 1 / -1;'><b>Searching...</b></div>";

        var filters = _getSearchFilters();
        var start = filters.start;
        var end = filters.end;

        var allBox = document.getElementById('search-all-records');
        var searchAll = allBox ? allBox.checked : false;

        // 1) Load persistent id_history for each ID (this is what guarantees you see ALL occurrences)
        var histSnaps = await Promise.all(idsToSearch.map(function(sid){
            return db.ref('id_history/' + sid).once('value');
        }));

        // 2) Also load packing/returns records from registos for completeness/backwards-compat
        var regSnap;
        if (searchAll) {
            regSnap = await db.ref('registos').once('value');
        } else {
            var regRef = db.ref('registos');
            if (start && end) regRef = regRef.orderByChild('dateClean').startAt(start).endAt(end);
            else regRef = regRef.orderByChild('dateClean');
            regSnap = await regRef.once('value');
        }
        var regData = regSnap.val() || {};

        // Batch metadata for carrier/name enrichment
// NOTE: cancellations can be stored only inside active_batches/<batch>/cancelled_ids (older data),
// so when searching CANCELLED (or status CANCELLED / search-all), load all batches for correct results.
var batchSnap;
var needAllBatches = true;
if (needAllBatches) {
    batchSnap = await db.ref('active_batches').once('value');
} else {
    var batchRef = db.ref('active_batches');
    // keep it range-limited for performance; id_history already carries full batch created/cancel events (new data)
    if (start && end) batchRef = batchRef.orderByChild('dateClean').startAt(start).endAt(end);
    else batchRef = batchRef.orderByChild('dateClean');
    batchSnap = await batchRef.once('value');
}
var batchData = batchSnap.val() || {};


        function _eventKey(ev){
            return [
                _fmt(ev.Type), _fmt(ev.DateTime), _fmt(ev.Batch), _fmt(ev.Carrier),
                _fmt(ev.User), _fmt(ev.Tracking), _fmt(ev.Items_or_Content), _fmt(ev.Details)
            ].join("||");
        }

        function _normalizeDateTimeAny(dtStr){
    var s = _fmt(dtStr).trim();
    if(!s) return "";
    // already normalized like YYYY-MM-DD ...
    if(/^\d{4}-\d{2}-\d{2}/.test(s)){
        // accept "YYYY-MM-DD HH:mm:ss" or ISO "YYYY-MM-DDTHH:mm:ss"
        s = s.replace('T',' ');
        return s.length >= 19 ? s.slice(0,19) : s;
    }
    // pt-PT locale like "DD/MM/YYYY, HH:MM:SS" (or without seconds/comma)
    var m = s.match(/^(\d{2})\/(\d{2})\/(\d{4})(?:,)?\s*(\d{2}:\d{2}(?::\d{2})?)/);
    if(m){
        var dd=m[1], mm=m[2], yy=m[3], tt=m[4];
        if(tt.length===5) tt = tt + ":00";
        return yy+"-"+mm+"-"+dd+" "+tt;
    }
    return s;
}

        idsToSearch.forEach(function(sid, ix){
            var events = [];
            var seen = new Set();

            // --- A) From id_history (covers BATCH_CREATED + CANCELLED + (new) PACKING/RETURNS) ---
            var hist = histSnaps[ix].val() || {};
            Object.values(hist).forEach(function(e){
                if(!e) return;
                var ev = {
                    ts: Number(e.ts || 0),
                    dateClean: _fmt(e.dateClean),
                    DateTime: _fmt(e.DateTime),
                    Type: _fmt(e.Type),
                    Batch: _fmt(e.Batch || e.batchName || e.BatchName || e.Batch_Key || e.BatchKey),
                    Carrier: _fmt(e.Carrier),
                    User: _fmt(e.User),
                    Tracking: _fmt(e.Tracking),
                    Items_or_Content: _fmt(e.Items_or_Content),
                    Details: _fmt(e.Details),
                    Customer: _fmt(e.Customer || ""),
                    Expected_Content: _fmt(e.Items_or_Content || "")
                };
                if(!ev.DateTime) ev.DateTime = _dt(ev.dateClean, _fmt(e.time));
                if(!ev.dateClean) ev.dateClean = ev.DateTime.slice(0,10);

                // Apply filters (type/date) here
                if (!_passesDate(ev.DateTime, start, end)) return;
                if (!_passesType(ev.Type, filters.type)) return;

                var k = _eventKey(ev);
                if(seen.has(k)) return;
                seen.add(k);
                events.push(ev);
            });

            // --- B) From registos (PACKING/RETURNS) ---
            Object.values(regData).forEach(function(r){
                if(!r || r.id !== sid) return;
                if(r.mode !== 'PACKING' && r.mode !== 'RETURN') return;

                var bKey = r.batch || "GENERAL";
                var b = batchData[bKey] || {};
                var batchName = b.name || bKey;
                var carrier = b.carrier || "N/A";

                var type = (r.mode === 'PACKING') ? "PACKING" : "RETURNS";
                if (!_passesType(type, filters.type)) return;

                var dt = _dtKey(r.dateClean, (r.endTime || r.time));
                if (!_passesDate(dt, start, end)) return;

                var ev2 = {
                    ts: (function(){
                        try{ return new Date(r.dateClean + "T" + (r.endTime || r.time)).getTime(); }catch(_){ return 0; }
                    })(),
                    dateClean: _fmt(r.dateClean),
                    DateTime: dt,
                    Type: type,
                    Batch: _fmt(batchName),
                    Carrier: _fmt(carrier),
                    User: _fmt(r.user),
                    Tracking: _fmt(r.track),
                    Items_or_Content: _fmt(r.prods),
                    Details: (type === "PACKING")
                        ? ("Start: " + _fmt(r.startTime || r.time) + " | Confirm: " + _fmt(r.endTime || r.time))
                        : "Return saved"
                };

                var k2 = _eventKey(ev2);
                if(seen.has(k2)) return;
                seen.add(k2);
                events.push(ev2);
            });
            // --- C) From active_batches cancelled_ids (backwards-compat for cancellations not stored in id_history) ---
Object.entries(batchData).forEach(function(pair){
    var bKey = pair[0];
    var b = pair[1] || {};
    if(!b || !b.cancelled_ids || !b.cancelled_ids[sid]) return;

    var cinfo = b.cancelled_ids[sid] || {};
    var dtRaw = cinfo.DateTime || ((cinfo.dateClean && cinfo.time) ? _dt(cinfo.dateClean, cinfo.time) : (cinfo.time || ""));
    var dtNorm = _normalizeDateTimeAny(dtRaw);
    var dc = _fmt(cinfo.dateClean) || (dtNorm ? dtNorm.slice(0,10) : "");
    var tPart = _fmt(cinfo.time) || (dtNorm && dtNorm.length >= 19 ? dtNorm.slice(11,19) : "");
    var ts3 = Number(cinfo.ts || 0);
    if(!ts3 && dc && tPart){
        try{ ts3 = new Date(dc + "T" + tPart).getTime(); }catch(_e){ ts3 = 0; }
    }

    var ev3 = {
        ts: ts3,
        dateClean: dc,
        DateTime: dtNorm || _dtKey(dc, tPart),
        Type: "CANCELLED",
        Batch: _fmt(b.name || bKey),
        Carrier: _fmt(b.carrier || "N/A"),
        User: _fmt(cinfo.user || cinfo.User || ""),
        Tracking: "",
        Items_or_Content: "",
        Details: "Reason: " + _fmt(cinfo.reason || cinfo.Reason || "")
    };

    if (!_passesDate(ev3.DateTime, start, end)) return;
    if (!_passesType(ev3.Type, filters.type)) return;

    var k3 = _eventKey(ev3);
    if(seen.has(k3)) return;
    seen.add(k3);
    events.push(ev3);
});

            
            // --- D) From active_batches expected_ids (fallback): show IDs even if only in a created batch ---
            // This guarantees SEARCH shows PENDING IDs that were added to a batch but have no registos yet,
            // and also covers older batches where id_history may be missing.
            (function(){
                try{
                    // If filters hide everything, we still want to show that the ID exists in some batch.
                    var allowOutOfRange = (events.length === 0);

                    Object.entries(batchData).forEach(function(pair){
                        var bKey = pair[0];
                        var b = pair[1] || {};
                        if(!b || !b.expected_ids) return;

                        // expected_ids can be array
                        var ex = b.expected_ids || [];
                        if(!Array.isArray(ex)) ex = Object.values(ex);

                        if(ex.indexOf(sid) === -1) return;

                        var od = (b.order_details && b.order_details[sid]) ? b.order_details[sid] : {};
                        var batchName = _fmt(b.name || bKey);
                        var carrier = _fmt(b.carrier || "N/A");

                        // Prefer createdAt (real creation timestamp), else fall back to batch date.
                        var dtRaw = _fmt(b.createdAt || "");
                        var dtNorm = dtRaw ? _normalizeDateTimeAny(dtRaw) : "";
                        var dc = _fmt(b.dateClean || "") || (dtNorm ? dtNorm.slice(0,10) : "");
                        if(!dtNorm){
                            // if we only have dateClean, give it a safe time
                            dtNorm = dc ? (dc + " 00:00:00") : "";
                        }
                        // Compute ts from dtNorm if possible
                        var ts4 = 0;
                        if(dtNorm && /^\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2}:\d{2}/.test(dtNorm)){
                            try{ ts4 = new Date(dtNorm.slice(0,10) + "T" + dtNorm.slice(11,19)).getTime(); }catch(_e){ ts4 = 0; }
                        }

                        var ev4 = {
                            ts: ts4,
                            dateClean: dc,
                            DateTime: dtNorm,
                            Type: "OFFICE / BATCH_CREATED",
                            Batch: batchName,
                            Carrier: carrier,
                            User: _fmt(b.createdBy || ""),
                            Tracking: "",
                            Items_or_Content: _fmt((od && od.content) ? od.content : ""),
                            Details: "Added to batch | Customer: " + _fmt((od && od.name) ? od.name : ""),
                            Customer: _fmt((od && od.name) ? od.name : "")
                        };

                        // Respect type filter always; date filter only if it wouldn't hide everything
                        if (!_passesType(ev4.Type, filters.type)) return;
                        if (!allowOutOfRange && !_passesDate(ev4.DateTime, start, end)) return;

                        var k4 = _eventKey(ev4);
                        if(seen.has(k4)) return;
                        seen.add(k4);
                        events.push(ev4);
                    });
                }catch(e){
                    console.warn("batch expected_ids fallback error:", e);
                }
            })();

// Sort oldest -> newest (ts preferred, fallback DateTime string)
            events.sort(function(a,b){
                var ta = Number(a.ts || 0), tb = Number(b.ts || 0);
                if(ta !== tb) return ta - tb;
                return _fmt(a.DateTime).localeCompare(_fmt(b.DateTime));
            });

            // Summary (based on the LATEST event, but keeping cancel/pack meta if they happened at any point)
            var summary = { status: "NOT FOUND" };
            if(events.length){
                var latest = events[events.length - 1];
                summary.lastEvent = _fmt(latest.DateTime);

                function _findLast(arr, predicate){
                    for(var i = arr.length - 1; i >= 0; i--){
                        if(predicate(arr[i])) return arr[i];
                    }
                    return null;
                }

                // pick latest batch-created info for customer/content (in case ID was re-added to new batch)
                var latestCreated = _findLast(events, function(ev){ return _fmt(ev.Type) === "OFFICE / BATCH_CREATED"; });
                if(latestCreated){
                    summary.batchName = _fmt(latestCreated.Batch);
                    summary.carrier = _fmt(latestCreated.Carrier);
                    summary.customer = _fmt(latestCreated.Customer);
                    summary.expectedContent = _fmt(latestCreated.Items_or_Content);
                } else {
                    // fallback from latest event
                    summary.batchName = _fmt(latest.Batch);
                    summary.carrier = _fmt(latest.Carrier);
                }

                var latestType = _fmt(latest.Type);
                if(latestType === "CANCELLED") summary.status = "CANCELLED";
                else if(_findLast(events, function(ev){ return _fmt(ev.Type) === "PACKING"; })) summary.status = "PACKED";
                else if(_findLast(events, function(ev){ return _fmt(ev.Type).indexOf("OFFICE") === 0; })) summary.status = "PENDING";
                else summary.status = "FOUND";

                // cancellation info (latest cancel event - highlight in UI, but do not hide later re-creations)
                var cancelEv = _findLast(events, function(ev){ return _fmt(ev.Type) === "CANCELLED"; });
                if(cancelEv){
                    summary.cancelReason = _fmt(cancelEv.Details).replace(/^Reason:\s*/,'');
                    summary.cancelBy = _fmt(cancelEv.User);
                    summary.cancelAt = _fmt(cancelEv.DateTime);
                }

                // packed info (latest packing event)
                var packEv = _findLast(events, function(ev){ return _fmt(ev.Type) === "PACKING"; });
                if(packEv){
                    summary.packedBy = _fmt(packEv.User);
                    summary.packedAt = _fmt(packEv.DateTime);
                    summary.tracking = _fmt(packEv.Tracking);
                }
            }

            // Status filter for cards
            var statusFilter = filters.status || "ALL";
            if(statusFilter !== "ALL" && _fmt(summary.status) !== statusFilter){
                // keep cache anyway, but card render will filter; still store
            }

            searchCache.eventsById[sid] = events;
            searchCache.summaryById[sid] = summary;
        });

        _renderSearchCards();
    }

function loadPerformanceStats() {
        const date = document.getElementById('perf-date-filter').value;
        const tbody = document.querySelector('#perf-table tbody');
        let stats = {};
        db.ref('registos').once('value', snap => {
            db.ref('pre_packing').once('value', preSnap => {
                Object.values(snap.val() || {}).forEach(r => { if(r.dateClean === date) { if(!stats[r.user]) stats[r.user] = { p:0, r:0, pre:0 }; if(r.mode === 'PACKING') stats[r.user].p++; if(r.mode === 'RETURN') stats[r.user].r++; } });
                Object.values(preSnap.val() || {}).forEach(p => { if(p.dateClean === date) { if(!stats[p.user]) stats[p.user] = { p:0, r:0, pre:0 }; stats[p.user].pre++; } });
                tbody.innerHTML = "";
                Object.keys(stats).sort().forEach(u => { const s = stats[u]; tbody.innerHTML += `<tr><td><b>${u}</b></td><td>${s.p}</td><td>${s.r}</td><td>${s.pre}</td><td>${s.p+s.r+s.pre}</td></tr>`; });
            });
        });
    }

    

    // ================================
    // üöö BATCH CARRIER EDIT (inside Batch Details modal)
    // ================================
    let __modalBatchId_forCarrier = null;
    let _carriersList = [];

    function _setModalCarrierStatus(msg, ok=true){
        const el = document.getElementById('modal-carrier-status');
        if(!el) return;
        el.style.display = msg ? 'block' : 'none';
        el.style.color = ok ? '#0f766e' : '#b91c1c';
        el.textContent = msg || '';
    }

    function renderBatchCarrierControls(batchId, batchObj, readOnly){
        try{
            __modalBatchId_forCarrier = batchId || null;
            const row = document.getElementById('modal-carrier-row');
            const sel = document.getElementById('modal-carrier-select');
            const btn = document.getElementById('modal-carrier-save');
            if(!row || !sel || !btn) return;

            // only admins can change carrier
            const canEdit = (!readOnly && currentUser && currentUser.email && currentUser.email.endsWith('@admin.com'));

            // show row for admins (edit) and also for readOnly? keep hidden for non-admin to avoid confusion
            row.style.display = (canEdit) ? 'block' : 'none';
            if(!canEdit) return;

            // build options from config; fallback defaults
            const list = (Array.isArray(_carriersList) && _carriersList.length) ? _carriersList : ['CTT','NACEX','CORREOS'];
            const current = (batchObj && batchObj.carrier) ? String(batchObj.carrier) : '';

            sel.innerHTML = '';
            list.forEach(c => {
                const opt = document.createElement('option');
                opt.value = c;
                opt.textContent = c;
                sel.appendChild(opt);
            });
            if(current && list.includes(current)) sel.value = current;
            else if(list.length) sel.value = list[0];

            _setModalCarrierStatus('');
        }catch(e){
            console.warn('renderBatchCarrierControls error', e);
        }
    }

    async function saveBatchCarrierFromModal(){
        try{
            const batchId = __modalBatchId_forCarrier;
            const sel = document.getElementById('modal-carrier-select');
            if(!batchId || !sel) return;

            if(!(currentUser && currentUser.email && currentUser.email.endsWith('@admin.com'))){
                return alert('Sem permiss√µes para editar transportadora.');
            }

            const newCarrier = String(sel.value || '').trim();
            if(!newCarrier) return alert('Transportadora inv√°lida.');

            // read current to avoid useless writes
            const snap = await db.ref('active_batches/' + batchId + '/carrier').once('value');
            const prev = snap.val() || '';
            if(String(prev) === String(newCarrier)){
                _setModalCarrierStatus('Sem altera√ß√µes (j√° estava ' + newCarrier + ').', true)
                return;
            }

            await db.ref('active_batches/' + batchId + '/carrier').set(newCarrier);
            logBatchAction(batchId, 'CARRIER UPDATE: ' + (prev || 'N/A') + ' -> ' + newCarrier);
            _setModalCarrierStatus('‚úÖ Guardado: ' + newCarrier);
        }catch(e){
            console.error(e);
            _setModalCarrierStatus('Erro ao guardar.', false);
            alert('Erro ao guardar transportadora.');
        }
    }

function logBatchAction(bId, msg) {
        const uname = (currentUser && currentUser.email) ? currentUser.email.split('@')[0].toUpperCase() : "SYSTEM";
        return db.ref(`active_batches/${bId}/history`).push({ time: _nowDateTime(), user: uname, msg });
    }



    // --- NEW: Persistent per-ID history (covers cancelled + recreated IDs across batches) ---
    // Normalized date/time storage:
    // - dateClean: YYYY-MM-DD
    // - time: HH:mm:ss (24h, always with seconds)
    // - DateTime: YYYY-MM-DD HH:mm:ss
    function _nowDateClean(){ return new Date().toISOString().slice(0, 10); }
    function _nowTime(){
        return new Intl.DateTimeFormat('pt-PT', {
            hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false
        }).format(new Date());
    }
    function _dt(dateClean, timeStr){ return (String(dateClean||"") + " " + String(timeStr||"")).trim(); }
    function _nowDateTime(){ return _dt(_nowDateClean(), _nowTime()); }

    async function pushIdHistory(orderId, entry){
        try{
            if(!orderId) return;
            const cleanId = String(orderId).trim();
            const e = entry || {};
            if(!e.ts) e.ts = Date.now();
            if(!e.dateClean) e.dateClean = _nowDateClean();
            if(!e.time) e.time = _nowTime();
            if(!e.DateTime) e.DateTime = _dt(e.dateClean, e.time);
            await db.ref(`id_history/${cleanId}`).push(e);
        }catch(err){
            console.error("pushIdHistory error", err);
        }
    }

    // --- NEW: INVENTORY QTY CHANGE LOGGING (shows in Modification Log) ---
    async function updateInventoryQty(batchId, skuKey, oldQty, newQtyVal) {
        try {
            const newQty = parseInt(newQtyVal, 10);
            const prevQty = parseInt(oldQty, 10);

            if (isNaN(newQty)) return alert("Quantidade inv√°lida.");
            if (newQty < 0) return alert("Quantidade n√£o pode ser negativa.");
            if (newQty === prevQty) return;

            await db.ref(`active_batches/${batchId}/inventory/${skuKey}/q`).set(newQty);
            logBatchAction(batchId, `INV QTY UPDATE: ${skuKey} | ${prevQty} -> ${newQty}`);
        } catch (e) {
            console.error(e);
            alert("Erro ao atualizar quantidade.");
        }
    }

    async function removeInventoryItem(batchId, skuKey, oldQty) {
        try {
            if (!confirm(`Remover o produto ${skuKey} do invent√°rio?`)) return;
            await db.ref(`active_batches/${batchId}/inventory/${skuKey}`).remove();
            logBatchAction(batchId, `INV ITEM REMOVED: ${skuKey} | was ${oldQty}`);
        } catch (e) {
            console.error(e);
            alert("Erro ao remover produto.");
        }
    }


    
// ===== Batch Details modal listener (avoid reopening / leaks) =====
let __editBatchRef = null;
let __editBatchCb = null;

let __editBatchId = null;

function stopEditBatchListener(){
  try{
    if(__editBatchRef && __editBatchCb) __editBatchRef.off('value', __editBatchCb);
  }catch(e){}
  __editBatchRef = null;
  __editBatchCb = null;
}

function openEditModal(batchId, readOnly = false) {
        if(!batchId) return;
        __editBatchId = batchId;
        // stop previous listener so it can't reopen later
        stopEditBatchListener();

        __editBatchRef = db.ref('active_batches/'+batchId);
        __editBatchCb = function(snap){
            const b = snap.val(); if(!b) return;
            document.getElementById('edit-batch-title').innerText = b.name;

const metaEl = document.getElementById('edit-batch-meta');
if(metaEl){
    const parts = [];
    parts.push(`<div><b>Status:</b> ${_fmt(b.status)}</div>`);
    if (b.carrier) parts.push(`<div><b>Carrier:</b> ${_fmt(b.carrier)}</div>`);
    if (b.pickedBy) parts.push(`<div><b>Picked by:</b> ${_fmt(b.pickedBy)}${b.pickedAt ? ` <span style="color:#666;">@ ${_fmt(b.pickedAt)}</span>` : ''}</div>`);
    metaEl.innerHTML = parts.join('');

    if(!b.pickedBy){
        getPickingInfo(batchId).then(info => {
            if(info && info.pickedBy){
                const parts2 = [];
                parts2.push(`<div><b>Status:</b> ${_fmt(b.status)}</div>`);
                if (b.carrier) parts2.push(`<div><b>Carrier:</b> ${_fmt(b.carrier)}</div>`);
                parts2.push(`<div><b>Picked by:</b> ${_fmt(info.pickedBy)}${info.pickedAt ? ` <span style="color:#666;">@ ${_fmt(info.pickedAt)}</span>` : ''}</div>`);
                metaEl.innerHTML = parts2.join('');
            }
        });
    }
}
            document.getElementById('modal-delete-btn').style.display = (readOnly || !currentUser.email.endsWith('@admin.com')) ? 'none' : 'block';
            // Carrier controls inside modal (admin)
            try{ renderBatchCarrierControls(batchId, b, readOnly); }catch(e){}
            const tbody = document.querySelector('#edit-inventory-table tbody'); tbody.innerHTML = "";
            Object.keys(b.inventory || {}).sort().forEach(k => {
                const it = b.inventory[k];
                tbody.innerHTML += `<tr><td>${k}</td><td>${readOnly ? it.q : `<input type="number" style="width:70px;" value="${it.q}" onchange="updateInventoryQty('${batchId}', '${k}', ${it.q}, this.value)">`}</td><td>${it.pos}</td>${readOnly ? '' : `<td><button class="btn-small btn-delete" onclick="removeInventoryItem('${batchId}', '${k}', ${it.q})">X</button></td>`}</tr>`;
            });
            const idsList = document.getElementById('edit-ids-list');
            let html = '<table><thead><tr><th>ID</th><th>Cliente</th><th>Content</th><th>Status</th><th>A√ß√£o</th></tr></thead><tbody>';
            (b.expected_ids||[]).forEach(id => {
                const isPack = (b.processed_ids && b.processed_ids[id]);
                const isCancelled = (b.cancelled_ids && b.cancelled_ids[id]);
                const det = (b.order_details||{})[id] || {name:"N/A", content:"N/A"};
                const cancelInfo = isCancelled ? b.cancelled_ids[id] : null;

                const idCell = isCancelled
                    ? `<span style="color:#b91c1c; text-decoration:line-through; font-weight:900;">${id}</span>`
                    : `<b>${id}</b>`;

                const nameCell = isCancelled
                    ? `<span style="color:#b91c1c; text-decoration:line-through;">${det.name || 'N/A'}</span>`
                    : `${det.name || 'N/A'}`;

                const contentCell = isCancelled
                    ? `<span style="color:#b91c1c; text-decoration:line-through;">${det.content || 'N/A'}</span>`
                    : `${det.content || 'N/A'}`;

                let statusTxt = 'PENDING';
                if (isPack) statusTxt = 'PACKED';
                if (isCancelled) statusTxt = 'CANCELADO';

                const statusCell = isCancelled
                    ? `<span style="color:#b91c1c; font-weight:900;">CANCELADO</span><div style="font-size:12px; color:#991b1b; margin-top:4px;">${(cancelInfo && cancelInfo.reason) ? ('Motivo: ' + cancelInfo.reason) : ''}</div>`
                    : (isPack ? '<span style="color:#166534; font-weight:900;">PACKED</span>' : '<span style="color:#92400e; font-weight:900;">PENDING</span>');

                const canCancel = (!readOnly && currentUser && currentUser.email && currentUser.email.endsWith('@admin.com'));
                const actionCell = isCancelled
                    ? `<button disabled style="opacity:.5; cursor:not-allowed;">CANCELLED</button>`
                    : (canCancel
                        ? `${isPack ? `<button class="btn-small" style="background:#0ea5e9; margin-right:8px;" onclick="openPackedItemsEditor('${batchId}', '${id}')">EDIT ITEMS</button>` : ''}<button class="btn-small btn-delete" onclick="cancelBatchId('${batchId}', '${id}', ${isPack ? 'true' : 'false'})">${isPack ? 'CANCEL (PACKED)' : 'CANCEL'}</button>`
                        : '-');
                html += `<tr><td>${idCell}</td><td>${nameCell}</td><td>${contentCell}</td><td>${statusCell}</td><td>${actionCell}</td></tr>`;
            });
            idsList.innerHTML = html + '</tbody></table>';
            const logBox = document.getElementById('qty-modification-log'); logBox.innerHTML = "";
            if(b.history) { Object.values(b.history).reverse().forEach(log => { logBox.innerHTML += `<div style="border-bottom:1px solid #eee; padding:4px;"><b>[${log.time}] ${log.user}:</b> ${log.msg}</div>`; }); }
            const cancelBox = document.getElementById('cancelled-ids-log'); cancelBox.innerHTML = "";
            if(b.cancelled_ids) { Object.values(b.cancelled_ids).reverse().forEach(c => { cancelBox.innerHTML += `<div><b>ID ${c.id}:</b> ${c.reason} <br><small>By ${c.user} at ${c.time}</small></div>`; }); }
                    };
        __editBatchRef.on('value', __editBatchCb);

        // open ONCE (user-driven), not on every realtime update
        document.getElementById('edit-batch-modal').style.display = 'flex';
    }

    function loadBatchData(bId) {
        if(!bId) return; 
        localStorage.setItem('lastPackingBatch', bId);

        if(activeBatchPath) db.ref(activeBatchPath).off();
        activeBatchPath = 'active_batches/' + bId;

        db.ref(activeBatchPath).on('value', s => {
            activeBatchData = s.val(); 
            if(!activeBatchData) return;

            // Allow access to COMPLETED batches, but lock packing actions unless READY_TO_PACK
            const st = activeBatchData.status || "";
            const canPack = (st === 'READY_TO_PACK');

            const finBtn = document.getElementById('btn-finalize-batch');
            if(finBtn) finBtn.style.display = canPack ? 'block' : 'none';

            const inp = document.getElementById('main-input');
            if(inp) inp.disabled = !canPack;

            // If locked, clear any partial scan UI
            if(!canPack) {
                document.getElementById('btn-confirm-order').style.display = 'none';
            }

            updateProcessedTable(bId);
        });
    }

    function updateProcessedTable(bId) {
        db.ref('registos').on('value', snap => {
            const tbody = document.querySelector('#recent-scans-table tbody'); tbody.innerHTML = "";
            const data = snap.val(); if(!data) return;
            Object.keys(data).reverse().forEach(key => {
                const r = data[key];
                if(r.batch === bId) {
                    const det = (activeBatchData && activeBatchData.order_details && activeBatchData.order_details[r.id]) ? activeBatchData.order_details[r.id] : {name:"---"};
                    tbody.innerHTML += `<tr><td>${r.time}</td><td><b>${r.id}</b></td><td>${det.name}</td><td><button class="btn-small btn-delete" onclick="removeRecentScan('${key}', '${r.id}', '${r.prods}', '${bId}')">X</button></td></tr>`;
                }
            });
        });
    }

    function removeRecentScan(recId, orderId, itemsStr, bId) { if(!confirm(`Apagar registo do ID ${orderId}?`)) return; db.ref('registos/' + recId).remove().then(() => { if(bId) db.ref(`active_batches/${bId}/processed_ids/${orderId}`).remove(); }); }

    function finishBatchPacking() {
        if(!activeBatchData) return;

        const requiredIds = getRequiredBatchIds(activeBatchData);
        const processedMap = activeBatchData.processed_ids || {};

        const processedRequiredCount = requiredIds.filter(id => processedMap[id]).length;
        const requiredCount = requiredIds.length;

        if(processedRequiredCount < requiredCount) {
            const missing = requiredIds.filter(id => !processedMap[id]);
            // show up to 10 missing to avoid huge alerts
            const sample = missing.slice(0, 10).join(', ');
            const more = missing.length > 10 ? ` (+${missing.length - 10} more)` : '';
            return alert(`ERRO: Faltam ${requiredCount - processedRequiredCount} IDs (excluindo cancelados).
Missing: ${sample}${more}`);
        }

        if(confirm("Fechar lote permanentemente? (IDs cancelados n√£o bloqueiam)")) {
            db.ref(activeBatchPath).update({status: 'COMPLETED'}).then(() => {
                localStorage.removeItem('lastPackingBatch');
                location.reload();
            });
        }
    }


    function loadPickingList() {
        const bId = document.getElementById('pick-batch-select').value; 
        if(!bId) return;

        db.ref('active_batches/'+bId).once('value', snap => {
            const b = snap.val() || {};
            const container = document.getElementById('picking-list-container'); 
            container.innerHTML = "";

            const canPick = (b.status === 'PENDING_PICK');

            Object.keys(b.inventory || {}).forEach(k => {
                const it = b.inventory[k];
                container.innerHTML += `
                    <div style="display:flex; align-items:center; padding:10px; border-bottom:1px solid #eee;">
                        <input type="checkbox" class="pk-check" style="width:30px; height:30px; margin-right:15px;" ${canPick ? '' : 'disabled'}>
                        <span><b>${it.q}x</b> - ${k}</span>
                        <span class="location-tag">üìç ${it.pos}</span>
                    </div>`;
            });

            // Always allow viewing details, even for READY/COMPLETED
            const btnDetails = document.getElementById('btn-pick-details');
            const btnAll = document.getElementById('btn-select-all');
            const btnFinish = document.getElementById('btn-finish-picking');

            if(btnDetails) btnDetails.style.display = 'block';

            // Only allow picking actions when batch is in PENDING_PICK
            if(btnAll) btnAll.style.display = canPick ? 'block' : 'none';
            if(btnFinish) btnFinish.style.display = canPick ? 'block' : 'none';
        });
    }

    function selectAllPicking() { document.querySelectorAll('.pk-check').forEach(c => c.checked = true); }
    function finishPicking() {
    const bId = document.getElementById('pick-batch-select').value;
    if(!bId) return;

    if(!currentUser || !currentUser.email) {
        return alert("ERRO: utilizador n√£o autenticado.");
    }

    const pickedBy = currentUser.email.split('@')[0].toUpperCase();
    const dc = _nowDateClean();
    const tm = _nowTime();
    const dt = _dtKey(dc, tm);

    // Keep original behavior first: update only the status (most likely allowed by rules)
    db.ref('active_batches/' + bId).update({ status: 'READY_TO_PACK' })
    .then(() => {
        // Best-effort extra writes (do not block finishing picking if rules reject them)
        const extra = [
            db.ref('active_batches/' + bId).update({
                pickedBy: pickedBy,
                pickedDateClean: dc,
                pickedTime: tm,
                pickedAt: dt
            }),
            // Local history (if permitted)
            db.ref(`active_batches/${bId}/history`).push({
                dateClean: dc,
                time: tm,
                DateTime: dt,
                ts: Date.now(),
                user: pickedBy,
                msg: "PICKING COMPLETE"
            }),
            // Global activity log (if permitted)
            db.ref('registos').push({
                mode: "PICKING",
                batch: bId,
                user: pickedBy,
                dateClean: dc,
                time: tm,
                DateTime: dt,
                ts: Date.now()
            })
        ];
        return Promise.allSettled(extra);
    })
    .then(() => location.reload())
    .catch(err => {
        console.error(err);
        alert("Erro ao finalizar picking. Ver consola.");
    });
}

    function renderManagementUI(all, fD) {
        const container = document.getElementById('mgmt-container');
        container.innerHTML = "";

        // Group batches by carrier for the selected day
        let gr = {};
        for (let k in all) {
            let b = all[k];
            if (b && b.dateClean === fD) {
                if (!gr[b.carrier]) gr[b.carrier] = [];
                gr[b.carrier].push({ ...b, id: k });
            }
        }

        // NEW: compute per-carrier TOTAL (unique IDs), DONE and PENDING (for the header)
        const carrierAgg = {};
        Object.keys(gr).forEach(c => {
            const allIds = new Set();
            const doneIds = new Set();
            gr[c].forEach(b => {
                const requiredIds = getRequiredBatchIds(b);
                requiredIds.forEach(id => {
                    allIds.add(id);
                    if (b.processed_ids && b.processed_ids[id]) doneIds.add(id);
                });
            });
            carrierAgg[c] = { tot: allIds.size, done: doneIds.size };
        });

        for (let c in gr) {
            let col = document.createElement('div');
            col.className = 'carrier-column';

            let color = c.includes('CTT') ? 'var(--color-ctt)' : (c.includes('NACEX') ? 'var(--color-nacex)' : 'var(--color-correos)');

            const agg = carrierAgg[c] || { tot: 0, done: 0 };
            const pend = Math.max(0, agg.tot - agg.done);

            // Header now shows totals per carrier
            let h = `
                <div class="carrier-header" style="background:${color}">
                    <div style="font-weight:900; font-size:16px; line-height:1;">${c}</div>
                    <div style="font-size:12px; font-weight:800; opacity:.95; margin-top:6px;">
                        TOTAL: ${agg.tot} &nbsp;|&nbsp; DONE: ${agg.done} &nbsp;|&nbsp; PEND: ${pend}
                    </div>
                </div>`;

            gr[c].forEach(b => {
                const requiredIds = getRequiredBatchIds(b);
                const tot = requiredIds.length;
                const done = requiredIds.filter(id => (b.processed_ids && b.processed_ids[id])).length;
                const perc = tot > 0 ? Math.round((done / tot) * 100) : 0;

                h += `<div class="batch-card"><h4>${b.name}</h4><div style="display:flex; justify-content:space-between; font-size:12px; color:#666;"><span>${perc}% Done</span><span>Status: ${b.status}</span></div>${b.pickedBy ? '<div style="margin-top:6px; font-size:12px; color:#444;"><b>Picked by:</b> ' + b.pickedBy + (b.pickedAt ? ' <span style="color:#666;">@ ' + b.pickedAt + '</span>' : '') + '</div>' : ''}<div class="progress-container"><div class="progress-bar" style="width:${perc}%"></div></div><div style="display:flex; gap:10px; margin-top:15px;"><button class="btn-small" style="background:var(--accent); flex:1;" onclick="openEditModal('${b.id}', false)">EDIT</button><button class="btn-small btn-delete" onclick="deleteBatch('${b.id}')">DEL</button></div></div>`;
            });

            col.innerHTML = h;
            container.appendChild(col);
        }
    }

    // ================================
// üöö CARRIER MANAGEMENT (OFFICE)
// ================================
function renderCarrierAdminList(carriers) {
    const box = document.getElementById('carrier-admin-list');
    if (!box) return;
    box.innerHTML = "";

    if (!carriers || !carriers.length) {
        box.innerHTML = "<div style='color:#666; font-style:italic;'>Nenhuma transportadora configurada.</div>";
        return;
    }

    carriers.forEach(c => {
        const row = document.createElement('div');
        row.style.display = 'flex';
        row.style.justifyContent = 'space-between';
        row.style.alignItems = 'center';
        row.style.padding = '12px';
        row.style.border = '1px solid #ddd';
        row.style.borderRadius = '10px';
        row.style.marginBottom = '8px';
        row.style.background = '#f9fafb';

        row.innerHTML = `<b>${c}</b>
            <button class="btn-small btn-delete" onclick="removeCarrier('${c}')">APAGAR</button>`;
        box.appendChild(row);
    });
}

async function addCarrier() {
    try {
        // Optional guard: only admins can edit carriers
        if (!(currentUser && currentUser.email && currentUser.email.endsWith('@admin.com'))) {
            return alert("Sem permiss√µes para editar transportadoras.");
        }

        const inp = document.getElementById('new-carrier-input');
        if (!inp) return;

        const name = (inp.value || "").trim().toUpperCase();
        if (!name) return alert("Nome inv√°lido.");

        const ref = db.ref('config/carriers');
        const snap = await ref.once('value');
        let carriers = snap.val() || [];

        if (!Array.isArray(carriers)) carriers = Object.values(carriers);

        if (carriers.includes(name)) {
            return alert("Essa transportadora j√° existe.");
        }

        carriers.push(name);
        carriers = carriers.filter(Boolean).map(x => String(x).trim().toUpperCase());
        carriers = Array.from(new Set(carriers)).sort();

        await ref.set(carriers);
        inp.value = "";
    } catch (e) {
        console.error(e);
        alert("Erro ao adicionar transportadora.");
    }
}

async function removeCarrier(name) {
    try {
        // Optional guard: only admins can edit carriers
        if (!(currentUser && currentUser.email && currentUser.email.endsWith('@admin.com'))) {
            return alert("Sem permiss√µes para editar transportadoras.");
        }

        if (!name) return;
        if (!confirm(`Apagar a transportadora "${name}"?`)) return;

        const ref = db.ref('config/carriers');
        const snap = await ref.once('value');
        let carriers = snap.val() || [];

        if (!Array.isArray(carriers)) carriers = Object.values(carriers);

        carriers = carriers.filter(c => String(c).trim().toUpperCase() !== String(name).trim().toUpperCase());
        carriers = carriers.filter(Boolean).map(x => String(x).trim().toUpperCase());
        carriers = Array.from(new Set(carriers)).sort();

        await ref.set(carriers);
    } catch (e) {
        console.error(e);
        alert("Erro ao apagar transportadora.");
    }
}

// --- Overview: "Pre-Packed Today" = total products scanned in PRE-PACKING for the selected day (ALL operators) ---
// Each scan in PRE-PACKING writes 1 record into /pre_packing (see handlePrePack push payload).
let _prepackQuery = null;
let _prepackCb = null;
function startPrepackCardListener(fD){
    try{
        // detach previous listener (date changes)
        if(_prepackQuery && _prepackCb){
            _prepackQuery.off('value', _prepackCb);
        }
        // Query only the selected day; count records (= products scanned)
        _prepackQuery = db.ref('pre_packing')
            .orderByChild('dateClean')
            .equalTo(fD)
            .limitToLast(800);

        _prepackCb = (snap) => {
            const cnt = snap.exists() ? snap.numChildren() : 0;
            const el = document.getElementById('card-prepack');
            if(el) el.innerText = cnt;
        };
        _prepackQuery.on('value', _prepackCb);
    }catch(e){
        console.warn("startPrepackCardListener error:", e);
    }
}
function stopPrepackCardListener(){
    try{
        if(_prepackQuery && _prepackCb) _prepackQuery.off('value', _prepackCb);
    }catch(e){}
    _prepackQuery = null;
    _prepackCb = null;
}
function loadPrepackCardOnce(fD){
    try{
        db.ref('pre_packing')
          .orderByChild('dateClean')
          .equalTo(fD)
          .limitToLast(800)
          .once('value')
          .then(snap => {
              const cnt = snap.exists() ? snap.numChildren() : 0;
              const el = document.getElementById('card-prepack');
              if(el) el.innerText = cnt;
          });
    }catch(e){
        console.warn("loadPrepackCardOnce error:", e);
    }
}

// ===== Realtime core wiring (avoid duplicate listeners) =====
let _activeBatchesRef = null;
let _activeBatchesCb  = null;
let _activeBatchesCache = {};
let _configWired = false;
let _currentSection = "";

function _todayDateClean(){
    try{ if(typeof _nowDateClean === 'function') return _nowDateClean(); }catch(e){}
    return new Date().toISOString().split('T')[0];
}
function _selectedOverviewDate(){
    const el = document.getElementById('global-date-filter');
    return (el && el.value) ? el.value : _todayDateClean();
}
function _overviewActive(){
    return _currentSection === 'sec-overview';
}

function initRealtimeCore(){
    // active batches: keep 1 listener for the whole app (used by selects, packing, picking)
    if(!_activeBatchesRef){
        _activeBatchesRef = db.ref('active_batches');
        _activeBatchesCb = (snap) => {
            _activeBatchesCache = snap.val() || {};

            // Always keep batch selects up to date (all sections)
            try{ updateSelects(_activeBatchesCache, _selectedOverviewDate()); }catch(e){}

            // Only auto-refresh OVERVIEW when it is open AND date == today
            const fD = _selectedOverviewDate();
            if(_overviewActive() && fD === _todayDateClean()){
                try{ updateDashboardStats(_activeBatchesCache, fD); }catch(e){}
                try{ renderManagementUI(_activeBatchesCache, fD); }catch(e){}
            }
        };
        _activeBatchesRef.on('value', _activeBatchesCb);
    }

    // config listeners: wire once
    if(!_configWired){
        _configWired = true;

        db.ref('config/master_products').on('value', s => {
            masterProductsDB = s.val() || {};
            try{ if(typeof updateMasterPreview==='function') updateMasterPreview(); }catch(e){}
        });

        db.ref('config/carriers').on('value', s => {
            const carriers = s.val() || ["CTT", "NACEX", "CORREOS"];

            // keep a normalized global list for other UIs (ex: Batch Details modal)
            try{
                _carriersList = (Array.isArray(carriers) ? carriers : Object.values(carriers))
                    .map(c => String(c).trim().toUpperCase())
                    .filter(Boolean);
                _carriersList = Array.from(new Set(_carriersList)).sort();
            }catch(e){ _carriersList = []; }

            const list = (_carriersList && _carriersList.length) ? _carriersList : ["CTT", "NACEX", "CORREOS"];

            const sel = document.getElementById('off-carrier-select');
            if(sel){
                sel.innerHTML = "";
                list.forEach(c => {
                    sel.innerHTML += `<option value="${c}">${c}</option>`;
                });
            }

            // also render admin list in OFFICE (if present)
            try { renderCarrierAdminList(list); } catch(e) {}

            // if the Batch Details modal is open, refresh options (keep selection)
            try{
                if(__modalBatchId_forCarrier && document.getElementById('edit-batch-modal') && document.getElementById('edit-batch-modal').style.display === 'flex'){
                    const cur = document.getElementById('modal-carrier-select') ? document.getElementById('modal-carrier-select').value : '';
                    const s2 = document.getElementById('modal-carrier-select');
                    if(s2){
                        s2.innerHTML = '';
                        list.forEach(c => {
                            const opt = document.createElement('option');
                            opt.value = c; opt.textContent = c;
                            s2.appendChild(opt);
                        });
                        if(cur && list.includes(cur)) s2.value = cur;
                    }
                }
            }catch(e){}
        });
    }
}

// OVERVIEW behavior:
// - If selected day == today: realtime updates (cards + kanban)
// - If selected day != today: snapshot only (no continuous updates) => old data only when user deliberately changes the date
function syncGlobalData() {
    const fD = _selectedOverviewDate();
    const today = _todayDateClean();

    // Only render/attach listeners when OVERVIEW is visible
    if(!_overviewActive()) return;

    if(fD === today){
        startPrepackCardListener(fD);
    }else{
        stopPrepackCardListener();
        loadPrepackCardOnce(fD);
    }

    // render immediately from the latest cache we have
    const bts = _activeBatchesCache || {};
    try{ updateDashboardStats(bts, fD); }catch(e){}
    try{ renderManagementUI(bts, fD); }catch(e){}
    try{ updateSelects(bts, fD); }catch(e){}
}

function showMetadata(id) {
        if(!activeBatchData) return;
        const cb = document.getElementById('meta-cancel-banner');
        if(activeBatchData.cancelled_ids && activeBatchData.cancelled_ids[id]) cb.style.display = 'flex'; else cb.style.display = 'none';
        if(activeBatchData.order_details && activeBatchData.order_details[id]) {
            document.getElementById('packing-info-display').style.display = 'block';
            document.getElementById('meta-cust-name').innerText = activeBatchData.order_details[id].name;
            document.getElementById('meta-inv-content').innerText = activeBatchData.order_details[id].content;
        }
    }

    function deleteBatch(id) { if(confirm("Apagar lote?")) db.ref('active_batches/'+id).remove(); }
    


    // Delete ENTIRE batch from the Batch Details modal
    function deleteBatchFromModal(){
        const id = __editBatchId;
        if(!id) return;
        if(!(currentUser && currentUser.email && currentUser.email.endsWith('@admin.com'))){
            return alert('Sem permiss√µes para apagar lotes.');
        }
        if(!confirm("Apagar lote?")) return;

        // Stop realtime listener so modal doesn't try to re-render while deleting
        try{ stopEditBatchListener(); }catch(e){}

        db.ref('active_batches/' + id).remove()
          .then(() => {
              // clear local saved batch selection if it was this one
              try{
                  if(localStorage.getItem('lastPackingBatch') === id) localStorage.removeItem('lastPackingBatch');
              }catch(e){}

              // close modal
              try{ closeModal('edit-batch-modal'); }catch(e){
                  // fallback if closeModal isn't available yet
                  const m = document.getElementById('edit-batch-modal');
                  if(m) m.style.display = 'none';
              }

              // best-effort refresh dropdowns/overview
              try{ syncGlobalData(); }catch(e){}
          })
          .catch(err => {
              console.error(err);
              alert("Erro ao apagar lote.");
          });
    }

    // Wire the modal delete button once
    (function(){
        try{
            const btn = document.getElementById('modal-delete-btn');
            if(btn) btn.onclick = deleteBatchFromModal;
        }catch(e){}
    })();

    // Helper (o OFF j√° tinha closeModal; isto complementa)
    function openModal(id) { document.getElementById(id).style.display = 'block'; }

    // ===== Packed Items Editor (corrigir itens dentro de IDs j√° PACKED) =====
    let packedEditState = null;

    function _splitPackedItems(prodsStr){
        if(!prodsStr) return [];
        return String(prodsStr)
            .split('|')
            .map(x => x.trim())
            .filter(Boolean);
    }

    function renderPackedItemsEditor(){
        const box = document.getElementById('edit-packed-items-list');
        if(!box || !packedEditState) return;

        box.innerHTML = packedEditState.items.map((it, idx) => {
            const safe = String(it).replace(/</g,'&lt;').replace(/>/g,'&gt;');
            return `
                <span class="prod-tag">
                    ${safe}
                    <button class="btn-small btn-delete" style="padding:6px 8px;" onclick="removePackedItemAt(${idx})">X</button>
                </span>
            `;
        }).join('');

        if(!packedEditState.items.length){
            box.innerHTML = "<div style='padding:10px; color:#666;'>Sem itens (vai gravar como No Items).</div>";
        }
    }

    function removePackedItemAt(idx){
        if(!packedEditState) return;
        const removed = packedEditState.items.splice(idx, 1)[0];
        packedEditState.removed.push(removed);
        renderPackedItemsEditor();
    }

    async function openPackedItemsEditor(batchKey, orderId){
        // encontra o √öLTIMO registo PACKING desse ID nesse batch
        const snap = await db.ref('registos').once('value');
        const all = snap.val() || {};

        let best = null; // { key, r, sortKey }
        Object.entries(all).forEach(([k, r]) => {
            if(!r) return;
            if(String(r.id||"").trim() !== String(orderId).trim()) return;
            if(String(r.batch||"") !== String(batchKey)) return;

            const mode = String(r.mode||"").toUpperCase();
            if(mode !== "PACKING") return;

            const sortKey = (r.dateClean || "") + " " + (r.endTime || r.time || "");
            if(!best || sortKey > best.sortKey) best = { key: k, r, sortKey };
        });

        if(!best){
            return alert("N√£o encontrei registo PACKING para este ID neste lote.");
        }

        packedEditState = {
            batchKey,
            orderId,
            sourceKey: best.key,
            source: best.r,
            items: _splitPackedItems(best.r.prods || ""),
            removed: []
        };

        document.getElementById('edit-packed-items-title').innerText =
            `Edit Packed Items ‚Äî ID ${orderId} (${batchKey})`;

        document.getElementById('edit-packed-items-note').value = "";
        renderPackedItemsEditor();
        openModal('edit-packed-items-modal');
    }

    async function savePackedItemsEditor(){
        if(!packedEditState) return;

        const endTime = _nowTime();
        const endTs = Date.now();
        const dc = _nowDateClean ? _nowDateClean() : new Date().toISOString().split('T')[0];
        const uname = (currentUser && currentUser.email) ? currentUser.email.split('@')[0].toUpperCase() : "UNKNOWN";

        const newProds = packedEditState.items.length ? packedEditState.items.join(' | ') : "No Items";
        const note = (document.getElementById('edit-packed-items-note').value || "").trim();

        // 1) grava um NOVO registo PACKING (corre√ß√£o) ‚Äî fica ‚Äúmais recente‚Äù
        await db.ref('registos').push({
            id: packedEditState.orderId,
            track: packedEditState.source.track || "",
            prods: newProds,
            mode: "PACKING",
            batch: packedEditState.batchKey,
            user: uname,
            startTime: packedEditState.source.startTime || "",
            endTime: endTime,
            startTs: (packedEditState.source && typeof packedEditState.source.startTs === 'number') ? packedEditState.source.startTs : null,
            endTs: endTs,
            time: endTime,
            dateClean: dc,

            // campos extra (opcionais, mas √∫teis)
            correction: true,
            correctionOf: packedEditState.sourceKey,
            removedItems: packedEditState.removed.join(' | ') || ""
        });

        // 2) adiciona evento ao ID history (para auditoria / rastreio)
        try{
            const bName = (activeBatchData && activeBatchData.name) ? activeBatchData.name : packedEditState.batchKey;
            const carr = (activeBatchData && activeBatchData.carrier) ? activeBatchData.carrier : "N/A";

            await pushIdHistory(packedEditState.orderId, {
                Type: "PACKING",
                BatchKey: packedEditState.batchKey,
                Batch: bName,
                Carrier: carr,
                User: uname,
                dateClean: dc,
                time: endTime,
                Tracking: packedEditState.source.track || "",
                Items_or_Content: newProds,
                Details: `CORRECTION | removed: ${packedEditState.removed.join(' | ') || '(none)'}${note ? (" | note: " + note) : ""}`
            });
        }catch(e){
            console.warn("pushIdHistory falhou (ignorado):", e);
        }

        closeModal('edit-packed-items-modal');
        alert("Corre√ß√£o gravada (ID mant√©m-se PACKED).");
    }


function closeModal(id) {
  document.getElementById(id).style.display = 'none';
  if(id === 'edit-batch-modal') stopEditBatchListener();
}
    function updateDashboardStats(all, fD) { 
        let nP = 0, nR = 0, nK = 0; for(let k in all) { let b = all[k]; if(b.dateClean === fD) { const requiredIds = getRequiredBatchIds(b);
            const nI = requiredIds.length, nE = requiredIds.filter(id => (b.processed_ids && b.processed_ids[id])).length; nP+=nI; nK+=nE; if(b.status==='READY_TO_PACK') nR+=(nI - nE); } } 
        document.getElementById('card-printed').innerText = nP; document.getElementById('card-ready').innerText = nR; document.getElementById('card-packed').innerText = nK; 
    }
    function updateSelects(bts, fD) {
        const selWH = document.getElementById('wh-batch-select'),
              selPK = document.getElementById('pick-batch-select');

        let pkOpt = '<option value="">-- SELECT BATCH (ANY STATUS) --</option>';
        let whOpt = '<option value="">-- SELECT BATCH (READY / COMPLETED) --</option>';

        // Build sortable list (newest first)
        const entries = Object.entries(bts || {}).filter(([k,b]) => b && (b.name || b.dateClean || b.carrier || b.status));
        entries.sort((a,b) => {
            const da = (a[1].dateClean || "");
            const dbb = (b[1].dateClean || "");
            if (dbb !== da) return dbb.localeCompare(da);
            const na = (a[1].name || a[0]);
            const nb = (b[1].name || b[0]);
            return nb.localeCompare(na);
        });

        entries.forEach(([k,b]) => {
            const date = b.dateClean || "";
            const name = b.name || k;
            const carrier = b.carrier || "N/A";
            const status = b.status || "UNKNOWN";
            const label = `${date} | ${name} | ${carrier} | ${status}`;

            // Picking dropdown: allow opening old batches for viewing
            pkOpt += `<option value="${k}">${label}</option>`;

            // Packing dropdown: show everything EXCEPT picking-only batches, but keep access to COMPLETED
            if (status !== 'PENDING_PICK') {
                whOpt += `<option value="${k}">${label}</option>`;
            }
        });

        if (selPK) selPK.innerHTML = pkOpt;
        if (selWH) {
            selWH.innerHTML = whOpt;
            const cur = localStorage.getItem('lastPackingBatch');
            if (cur && selWH.querySelector(`option[value="${cur}"]`)) selWH.value = cur;
        }
    }
    function updateMasterPreview() { const tbody = document.querySelector('#master-db-table tbody'), search = document.getElementById('master-search').value.toUpperCase(); tbody.innerHTML = ""; Object.keys(masterProductsDB).forEach(k => { if (k.includes(search) || masterProductsDB[k].toUpperCase().includes(search)) { tbody.innerHTML += `<tr><td>${k}</td><td>${masterProductsDB[k]}</td></tr>`; } }); }
    function handleCSVUpload(){
  const fileInput = document.getElementById('csv-file-input');
  const statusEl  = document.getElementById('master-upload-status');

  if(!fileInput || !fileInput.files || !fileInput.files.length){
    alert("Selecione um ficheiro CSV primeiro.");
    return;
  }

  // Split CSV line respecting quotes
  function splitCSVLine(line, delim){
    const out = [];
    let cur = "";
    let inQ = false;

    for(let i=0;i<line.length;i++){
      const ch = line[i];

      if(ch === '"'){
        // handle escaped quote ""
        if(inQ && line[i+1] === '"'){
          cur += '"';
          i++;
        }else{
          inQ = !inQ;
        }
      }else if(ch === delim && !inQ){
        out.push(cur);
        cur = "";
      }else{
        cur += ch;
      }
    }
    out.push(cur);
    return out;
  }

  function detectDelimiter(headerLine){
    const delims = [',',';','\t'];
    let best = ',';
    let bestCount = 0;
    delims.forEach(d=>{
      const c = splitCSVLine(headerLine, d).length;
      if(c > bestCount){
        bestCount = c;
        best = d;
      }
    });
    return best;
  }

  const reader = new FileReader();
  reader.onload = async function(e){
    try{
      const txt = (e && e.target && e.target.result) ? String(e.target.result) : "";
      const lines = txt.split(/\r?\n/).map(l=>l.trim()).filter(Boolean);

      if(lines.length < 2){
        if(statusEl) statusEl.textContent = "CSV inv√°lido: precisa de cabe√ßalho + pelo menos 1 linha de dados.";
        alert("CSV inv√°lido: precisa de cabe√ßalho + pelo menos 1 linha de dados.");
        return;
      }

      const delim = detectDelimiter(lines[0]); // header
      const newMaster = {};
      let skipped = 0;

      // Format requested:
      // Coluna A = NOME DO PRODUTO
      // Coluna B = C√ìDIGO DE BARRAS
      // Linha 1 = CABE√áALHO (ignorar)
      for(let i=1;i<lines.length;i++){
        const cols = splitCSVLine(lines[i], delim);
        if(!cols || cols.length < 2){
          skipped++;
          continue;
        }

        const name = (cols[0] || "").replace(/^"|"$/g, "").trim();
        const bar  = (cols[1] || "").replace(/^"|"$/g, "").trim();

        if(!bar){
          skipped++;
          continue;
        }

        newMaster[String(bar).toUpperCase()] = name || "";
      }

      const total = Object.keys(newMaster).length;
      if(total === 0){
        const msg = "N√£o encontrei barcodes v√°lidos. Confirma: Coluna A=Nome, Coluna B=Barcode, e a linha 1 √© cabe√ßalho.";
        if(statusEl) statusEl.textContent = msg;
        alert(msg);
        return;
      }

      if(statusEl) statusEl.textContent = "A enviar para a base de dados...";
      await db.ref('config/master_products').set(newMaster);

      masterProductsDB = newMaster;
      if(statusEl) statusEl.textContent = "‚úÖ Master Data atualizada ("+total+" barcodes). Linhas ignoradas: "+skipped+".";
      try{ updateMasterPreview(); }catch(err){}

      alert("Master Data carregada com sucesso ("+total+" barcodes).");
      fileInput.value = "";
    }catch(err){
      console.error(err);
      if(statusEl) statusEl.textContent = "Erro no upload: " + (err && err.message ? err.message : err);
      alert("Erro a processar o CSV: " + (err && err.message ? err.message : err));
    }
  };
  reader.readAsText(fileInput.files[0]);
}

    async function createBatch() {
        const n = document.getElementById('off-batch-name').value.trim(),
              c = document.getElementById('off-carrier-select').value,
              tD = document.getElementById('off-batch-date').value;
        if(!n || !tD) return alert("Missing info.");

        const key = safeKey(n + "_" + c + "_" + tD + "_" + Date.now());

        let inv = {};
        document.getElementById('off-products-list').value.split('\n').forEach(l => {
            let p = l.split('\t');
            if(p.length>=2) inv[p[0].trim().toUpperCase()] = { q: parseInt(p[1]), pos: p[2] || "??" };
        });

        let det = {};
        let ids = [];
        document.getElementById('off-order-meta').value.split('\n').forEach(l => {
            let p = l.split('\t');
            if(p.length>=1 && p[0].trim()) {
                ids.push(p[0].trim());
                det[p[0].trim()] = { name: p[1]||"N/A", content: p[2]||"N/A" };
            }
        });

        const createdBy = (currentUser && currentUser.email) ? currentUser.email.split('@')[0].toUpperCase() : "SYSTEM";
        const createdAt = _nowDateTime();

        await db.ref('active_batches/'+key).set({
            name: n,
            carrier: c,
            expected_ids: ids,
            inventory: inv,
            order_details: det,
            status:'PENDING_PICK',
            dateClean: tD,
            createdBy: createdBy,
            createdAt: createdAt
        });

        // NEW: persist per-ID history so SEARCH can show all occurrences (cancelled + recreated)
        const createdTime = _nowTime();
        await Promise.all((ids || []).map(function(orderId){
            const od = det[orderId] || {};
            return pushIdHistory(orderId, {
                Type: "OFFICE / BATCH_CREATED",
                BatchKey: key,
                Batch: n,
                Carrier: c,
                User: createdBy,
                dateClean: tD,
                time: createdTime,
                Tracking: "",
                Items_or_Content: od.content || "",
                Customer: od.name || "",
                Details: "Added to batch | Customer: " + (od.name || "")
            });
        }));

        alert("Created!");
        document.getElementById('off-batch-name').value="";
        document.getElementById('off-products-list').value="";
        document.getElementById('off-order-meta').value="";
}

function handlePrePack(v) { const key = safeKey(v); const prodName = masterProductsDB[key] || "UNKNOWN SKU"; db.ref('pre_packing').push({ product: prodName, user: currentUser.email.split('@')[0].toUpperCase(), time: _nowTime(), dateClean: new Date().toISOString().split('T')[0] }).then(() => { resetScan(); loadPrePackHistory(); }); }
    function loadRecentReturns() { db.ref('registos').limitToLast(10).on('value', snap => { const tbody = document.querySelector('#recent-returns-table tbody'); tbody.innerHTML = ""; const data = snap.val(); if(!data) return; Object.keys(data).reverse().forEach(k => { const r = data[k]; if(r.mode === 'RETURN') tbody.innerHTML += `<tr><td>${r.time}</td><td><b>${r.id}</b></td><td>${r.prods}</td><td><button class="btn-small btn-delete" onclick="db.ref('registos/${k}').remove()">X</button></td></tr>`; }); }); }
    function loadPrePackHistory() { const fD = new Date().toISOString().split('T')[0]; db.ref('pre_packing').on('value', snap => { const tbody = document.querySelector('#prepack-recent-table tbody'); tbody.innerHTML = ""; if(!snap.val()) return; Object.keys(snap.val()).reverse().forEach(k => { const r = snap.val()[k]; if(r.dateClean === fD) tbody.innerHTML += `<tr><td>${r.time}</td><td>${r.product}</td><td><button class="btn-small btn-delete" onclick="db.ref('pre_packing/${k}').remove()">X</button></td></tr>`; }); }); }
    function updateDisplay(m) { const p = (m === 'RETURN' ? 'rv-' : 'v-'); document.getElementById(p+'id').innerText = scanData.id||"-"; document.getElementById(p+'track').innerText = scanData.track||"-"; const container = document.getElementById(p+'prods'); container.innerHTML = ""; scanData.prods.forEach(name => { container.innerHTML += `<div class="prod-tag"><span>${name}</span></div>`; }); }

    document.getElementById('main-input').addEventListener('keypress', e => { if(e.key==='Enter'){ handleScan(e.target.value.trim()); e.target.value=""; } });


    
// ===== PERFORMANCE: DAILY SUMMARY + OPERATOR HISTORY (PRE-PACKING / PACKING / RETURNS) =====
(function(){
  function _fmt(v){ return (v===undefined || v===null) ? "" : String(v); }
  function _upperUser(u){ return _fmt(u).trim().toUpperCase(); }

  function _normalizeProductToken(t){
    t = _fmt(t).trim();
    if(!t) return "";
    // If older logs stored barcode instead of name, map it using masterProductsDB
    try{
      var key = t.toUpperCase();
      if(window.masterProductsDB && masterProductsDB[key]) return _fmt(masterProductsDB[key]).trim();
    }catch(_e){}
    return t;
  }

  function _splitProductsField(prodsField){
    if(prodsField === undefined || prodsField === null) return [];
    if(Array.isArray(prodsField)) return prodsField.map(_normalizeProductToken).filter(Boolean);
    if(typeof prodsField === 'object') return Object.keys(prodsField).map(_normalizeProductToken).filter(Boolean);
    var s = String(prodsField).trim();
    if(!s || s.toLowerCase()==='no items') return [];
    return s.split('|').map(function(x){ return _normalizeProductToken(x); }).filter(Boolean);
  }

  function _countProducts(prodsField){
    // Count products by operator scans (after mapping barcodes -> product names if needed)
    return _splitProductsField(prodsField).length;
  }

  function _csvEscape(s){
    s = _fmt(s);
    if(s.includes('"') || s.includes(",") || s.includes("\n")) return '"' + s.replace(/"/g,'""') + '"';
    return s;
  }

  function _prepackOrderId(p){
    return _fmt(p.id || p.orderId || p.order || p.order_id || '');
  }

  function _downloadCSV(filename, rows){
    var csv = rows.map(function(r){ return r.map(_csvEscape).join(","); }).join("\n");
    var blob = new Blob([csv], {type:"text/csv;charset=utf-8;"});
    var url = URL.createObjectURL(blob);
    var a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    setTimeout(function(){ URL.revokeObjectURL(url); }, 2500);
  }

  async function _loadDayData(dateClean){
    // registos: packing + returns
    // pre_packing: prepack actions
    var regSnap = await db.ref('registos').orderByChild('dateClean').equalTo(dateClean).once('value');
    var regObj = regSnap.val() || {};

    // pre_packing can be structured differently; attempt by date index first, fallback to full scan of that day
    var ppSnap = await db.ref('pre_packing').orderByChild('dateClean').equalTo(dateClean).once('value');
    var ppObj = ppSnap.val() || {};

    // Normalize lists
    var regList = Object.values(regObj).filter(Boolean);
    var ppList = Object.values(ppObj).filter(Boolean);

    return {regList: regList, ppList: ppList};
  }

  function _collectOperators(regList, ppList){
    var set = {};
    regList.forEach(function(r){
      if(r && r.user) set[_upperUser(r.user)] = true;
    });
    ppList.forEach(function(p){
      if(p && (p.user || p.operator)) set[_upperUser(p.user || p.operator)] = true;
    });
    return Object.keys(set).sort();
  }

  function _applyOperatorFilter(list, operatorUpper, mode){
    if(!operatorUpper || operatorUpper==="ALL") return list;
    return list.filter(function(x){
      var u = _upperUser(x.user || x.operator || "");
      return u === operatorUpper;
    });
  }

  function _buildDailySummary(dateClean, regList, ppList){
    var packed = regList.filter(function(r){ return r && r.mode === 'PACKING'; });
    var returns = regList.filter(function(r){ return r && (r.mode === 'RETURN' || r.mode === 'RETURNS'); });

    var prepack = ppList; // pre_packing entries

    // Totals
    var totalPackedIds = packed.length;
    var totalReturnIds = returns.length;

    var totalPackedProducts = packed.reduce(function(acc,r){ return acc + _countProducts(r.prods); }, 0);
    var totalReturnProducts = returns.reduce(function(acc,r){ return acc + _countProducts(r.prods); }, 0);

    // Pre-pack counts are based on operator scans (each record = 1 product scan)
    var totalPrepackProducts = prepack.length;
    var _ppIdsSet = {};
    prepack.forEach(function(p){ var oid=_prepackOrderId(p); if(oid) _ppIdsSet[oid]=true; });
    var totalPrepackIds = Object.keys(_ppIdsSet).length;

    // Per-operator rollups
    function rollReg(list){
      var by = {};
      list.forEach(function(x){
        var u = _upperUser(x.user || "UNKNOWN");
        by[u] = by[u] || {ids:0, prods:0};
        by[u].ids += 1;                 // each record is an ID
        by[u].prods += _countProducts(x.prods); // count scanned products (names)
      });
      return by;
    }

    function rollPrepack(list){
      var by = {};
      var seen = {}; // per operator unique order ids
      list.forEach(function(x){
        var u = _upperUser(x.user || x.operator || "UNKNOWN");
        by[u] = by[u] || {ids:0, prods:0};
        by[u].prods += 1; // each pre_packing record = 1 product scan
        var oid = _prepackOrderId(x);
        seen[u] = seen[u] || {};
        if(oid && !seen[u][oid]){
          seen[u][oid] = true;
          by[u].ids += 1; // unique orders touched in pre-packing
        }
      });
      return by;
    }

    var packBy = rollReg(packed);
    var retBy  = rollReg(returns);
    var ppBy   = rollPrepack(prepack);
// Merge operator list
    var ops = {};
    Object.keys(packBy).forEach(function(u){ ops[u]=true; });
    Object.keys(retBy).forEach(function(u){ ops[u]=true; });
    Object.keys(ppBy).forEach(function(u){ ops[u]=true; });

    var users = Object.keys(ops).sort();

    var html = '';
    html += '<div class="grid-2" style="margin-top:10px;">';
    html += '  <div class="card"><b>PACKING (dia)</b><div style="margin-top:8px;">IDs embalados: <b>'+totalPackedIds+'</b><br>Produtos embalados: <b>'+totalPackedProducts+'</b></div></div>';
    html += '  <div class="card"><b>RETURNS (dia)</b><div style="margin-top:8px;">IDs returns: <b>'+totalReturnIds+'</b><br>Produtos returns: <b>'+totalReturnProducts+'</b></div></div>';
    html += '</div>';

    html += '<div class="card" style="margin-top:10px;"><b>PRE-PACKING (dia)</b><div style="margin-top:8px;">Registos pre-packing: <b>'+totalPrepackIds+'</b><br>Produtos em pre-packing: <b>'+totalPrepackProducts+'</b></div></div>';

    html += '<div class="card" style="margin-top:10px;">';
    html += '<b>Resumo di√°rio por colaborador</b>';
    html += '<div style="font-size:12px; color:#666; margin-top:6px;">Dia: <b>'+dateClean+'</b></div>';
    html += '<div style="overflow:auto; margin-top:10px;">';
    html += '<table style="width:100%; border-collapse:collapse;">';
    html += '<thead><tr style="text-align:left;"><th style="padding:8px; border-bottom:1px solid #eee;">Operador</th>'
          + '<th style="padding:8px; border-bottom:1px solid #eee;">Packing IDs</th><th style="padding:8px; border-bottom:1px solid #eee;">Packing Produtos</th>'
          + '<th style="padding:8px; border-bottom:1px solid #eee;">Returns IDs</th><th style="padding:8px; border-bottom:1px solid #eee;">Returns Produtos</th>'
          + '<th style="padding:8px; border-bottom:1px solid #eee;">Pre-Pack Registos</th><th style="padding:8px; border-bottom:1px solid #eee;">Pre-Pack Produtos</th>'
          + '</tr></thead><tbody>';

    users.forEach(function(u){
      var p = packBy[u] || {ids:0, prods:0};
      var r = retBy[u]  || {ids:0, prods:0};
      var pp= ppBy[u]   || {ids:0, prods:0};
      html += '<tr>'
           + '<td style="padding:8px; border-bottom:1px solid #f3f4f6; font-weight:900;">'+u+'</td>'
           + '<td style="padding:8px; border-bottom:1px solid #f3f4f6;">'+p.ids+'</td>'
           + '<td style="padding:8px; border-bottom:1px solid #f3f4f6;">'+p.prods+'</td>'
           + '<td style="padding:8px; border-bottom:1px solid #f3f4f6;">'+r.ids+'</td>'
           + '<td style="padding:8px; border-bottom:1px solid #f3f4f6;">'+r.prods+'</td>'
           + '<td style="padding:8px; border-bottom:1px solid #f3f4f6;">'+pp.ids+'</td>'
           + '<td style="padding:8px; border-bottom:1px solid #f3f4f6;">'+pp.prods+'</td>'
           + '</tr>';
    });

    html += '</tbody></table></div>';
    html += '</div>';

    return {
      html: html,
      totals: {
        dateClean: dateClean,
        packing_ids: totalPackedIds,
        packing_products: totalPackedProducts,
        returns_ids: totalReturnIds,
        returns_products: totalReturnProducts,
        prepack_records: totalPrepackIds,
        prepack_products: totalPrepackProducts
      }
    };
  }

  function _buildHistory(dateClean, regList, ppList, operatorUpper){
    var regF = _applyOperatorFilter(regList, operatorUpper);
    var ppF  = _applyOperatorFilter(ppList, operatorUpper);

    // Build unified event list
    var events = [];

    regF.forEach(function(r){
      if(!r) return;
      var mode = r.mode || '';
      if(mode !== 'PACKING' && mode !== 'RETURN' && mode !== 'RETURNS') return;
      events.push({
        ts: r.ts ? r.ts : (r.timeIso ? Date.parse(r.timeIso) : 0),
        type: (mode==='PACKING' ? 'PACKING' : 'RETURNS'),
        id: _fmt(r.id),
        user: _upperUser(r.user),
        track: _fmt(r.track),
        prods: (_splitProductsField(r.prods).join(' | ') || _fmt(r.prods)),
        extra: 'Batch: ' + _fmt(r.batch) + ' | Start: ' + _fmt(r.startTime) + ' | End: ' + _fmt(r.endTime)
      });
    });

    ppF.forEach(function(p){
      if(!p) return;
      events.push({
        ts: p.ts ? p.ts : (p.timeIso ? Date.parse(p.timeIso) : 0),
        type: 'PRE-PACKING',
        id: _prepackOrderId(p),
        user: _upperUser(p.user || p.operator),
        track: _fmt(p.track || ''),
        prods: _fmt(p.product || p.prodName || p.item || ''),
        extra: _fmt(p.note || p.notes || '')
      });
    });

    events.sort(function(a,b){ return (b.ts||0) - (a.ts||0); });

    if(!events.length){
      return '<div class="card">Sem hist√≥rico para este filtro.</div>';
    }

    var html = '<div style="overflow:auto;"><table style="width:100%; border-collapse:collapse;">'
      + '<thead><tr style="text-align:left;">'
      + '<th style="padding:8px; border-bottom:1px solid #eee;">Tipo</th>'
      + '<th style="padding:8px; border-bottom:1px solid #eee;">ID</th>'
      + '<th style="padding:8px; border-bottom:1px solid #eee;">Operador</th>'
      + '<th style="padding:8px; border-bottom:1px solid #eee;">Tracking</th>'
      + '<th style="padding:8px; border-bottom:1px solid #eee;">Produtos</th>'
      + '<th style="padding:8px; border-bottom:1px solid #eee;">Detalhes</th>'
      + '</tr></thead><tbody>';

    events.forEach(function(ev){
      html += '<tr>'
        + '<td style="padding:8px; border-bottom:1px solid #f3f4f6; font-weight:900;">'+ev.type+'</td>'
        + '<td style="padding:8px; border-bottom:1px solid #f3f4f6;">'+_fmt(ev.id)+'</td>'
        + '<td style="padding:8px; border-bottom:1px solid #f3f4f6;">'+_fmt(ev.user)+'</td>'
        + '<td style="padding:8px; border-bottom:1px solid #f3f4f6;">'+_fmt(ev.track)+'</td>'
        + '<td style="padding:8px; border-bottom:1px solid #f3f4f6;">'+_fmt(ev.prods)+'</td>'
        + '<td style="padding:8px; border-bottom:1px solid #f3f4f6; font-size:12px; color:#555;">'+_fmt(ev.extra)+'</td>'
        + '</tr>';
    });

    html += '</tbody></table></div>';
    return html;
  }

  async function perfLoadSummary(){
    var dayEl = document.getElementById('perf-day');
    var opEl = document.getElementById('perf-operator');
    var day = dayEl ? dayEl.value : "";
    if(!day) return alert("Seleciona um dia.");

    var wrap = document.getElementById('perf-daily-summary');
    if(wrap) wrap.innerHTML = "<div class='card'>A carregar...</div>";

    var data = await _loadDayData(day);
    var ops = _collectOperators(data.regList, data.ppList);

    // populate operators dropdown (keep current selection)
    if(opEl){
      var cur = opEl.value || "ALL";
      opEl.innerHTML = '<option value="ALL">Todos</option>' + ops.map(function(u){ return '<option value="'+u+'">'+u+'</option>'; }).join('');
      if(ops.indexOf(cur)!==-1) opEl.value = cur;
    }

    var summary = _buildDailySummary(day, data.regList, data.ppList);
    if(wrap) wrap.innerHTML = summary.html;

    // store last data for history/export
    window.__perf_last = {day: day, regList: data.regList, ppList: data.ppList};
  }

  function perfToggleHistory(){
    var w = document.getElementById('perf-history-wrap');
    if(!w) return;
    w.style.display = (w.style.display === 'none' || !w.style.display) ? 'block' : 'none';
  }

  function perfRenderHistory(){
    var state = window.__perf_last;
    if(!state) return alert("Primeiro clica em 'Carregar resumo di√°rio'.");
    var opEl = document.getElementById('perf-operator');
    var operator = opEl ? opEl.value : "ALL";
    var list = document.getElementById('perf-history-list');
    if(list) list.innerHTML = "<div class='card'>A carregar hist√≥rico...</div>";
    var html = _buildHistory(state.day, state.regList, state.ppList, operator);
    if(list) list.innerHTML = html;
  }

  function perfExportCSV(){
    var state = window.__perf_last;
    if(!state) return alert("Primeiro clica em 'Carregar resumo di√°rio'.");
    var opEl = document.getElementById('perf-operator');
    var operator = opEl ? opEl.value : "ALL";

    var regF = _applyOperatorFilter(state.regList, operator);
    var ppF  = _applyOperatorFilter(state.ppList, operator);

    var rows = [];
    rows.push(["date","type","id","operator","tracking","products","extra"]);

    regF.forEach(function(r){
      if(!r) return;
      var mode = r.mode || '';
      if(mode !== 'PACKING' && mode !== 'RETURN' && mode !== 'RETURNS') return;
      rows.push([state.day, (mode==='PACKING'?'PACKING':'RETURNS'), _fmt(r.id), _upperUser(r.user), _fmt(r.track), _fmt(r.prods),
        "batch="+_fmt(r.batch)+" start="+_fmt(r.startTime)+" end="+_fmt(r.endTime)]);
    });

    ppF.forEach(function(p){
      if(!p) return;
      rows.push([state.day, "PRE-PACKING", _prepackOrderId(p), _upperUser(p.user || p.operator), _fmt(p.track || ''), _fmt(p.product || p.prodName || p.item || ''), _fmt(p.note || p.notes || '')]);
    });

    _downloadCSV("performance_"+state.day+"_"+operator+".csv", rows);
  }

  function wire(){
    var dayEl = document.getElementById('perf-day');
    if(dayEl && !dayEl.value){
      // default to today (local)
      var now = new Date();
      var y = now.getFullYear();
      var m = String(now.getMonth()+1).padStart(2,'0');
      var d = String(now.getDate()).padStart(2,'0');
      dayEl.value = y+"-"+m+"-"+d;
    }

    var btn1 = document.getElementById('btn-perf-load');
    var btn2 = document.getElementById('btn-perf-history');
    var btn3 = document.getElementById('btn-perf-export');
    var opEl = document.getElementById('perf-operator');

    if(btn1) btn1.onclick = perfLoadSummary;
    if(btn2) btn2.onclick = function(){ perfToggleHistory(); perfRenderHistory(); };
    if(btn3) btn3.onclick = perfExportCSV;

    if(opEl) opEl.onchange = function(){
      // if history is open, refresh it
      var w = document.getElementById('perf-history-wrap');
      if(w && w.style.display !== 'none') perfRenderHistory();
    };
  }

  document.addEventListener('DOMContentLoaded', function(){
    // wire only once
    setTimeout(wire, 300);
  });
})();

// --- FIX: CANCEL BUTTON IN EDIT BATCH MODAL ---
    async function cancelBatchId(batchId, orderId, wasPacked) {
        try {
            // Permitir cancelar mesmo depois de embalado (PACKED)
            if (wasPacked) {
                const ok = confirm(`ATEN√á√ÉO: O ID ${orderId} j√° est√° PACKED.\n\nSe cancelares, vai ficar marcado como CANCELADO no lote (com motivo), e deixa de contar para finalizar o lote.\nO hist√≥rico de packing continua nos registos.\n\nQueres continuar?`);
                if (!ok) return;
            }
            const reason = prompt(`Motivo do cancelamento para o ID ${orderId}?`);
            if (!reason || !reason.trim()) return;

            const dc = _nowDateClean();
            const tm = _nowTime();
            const payload = {
                id: orderId,
                reason: reason.trim(),
                user: (currentUser && currentUser.email ? currentUser.email.split('@')[0].toUpperCase() : "UNKNOWN"),
                ts: Date.now(),
                dateClean: dc,
                time: tm,
                DateTime: _dt(dc, tm)
            };

            // Store cancellation info
            await db.ref(`active_batches/${batchId}/cancelled_ids/${orderId}`).set(payload);

            // If it was marked processed, remove to avoid PACKED + CANCELLED inconsistency
            await db.ref(`active_batches/${batchId}/processed_ids/${orderId}`).remove();

            // Log action in batch history
            logBatchAction(batchId, `CANCELLED ID: ${orderId} | Reason: ${payload.reason}`);

            // NEW: persistent ID history so SEARCH shows cancelled even if the ID is recreated in new batches
            try{
                const bSnap = await db.ref(`active_batches/${batchId}`).once('value');
                const b = bSnap.val() || {};
                const dc = _nowDateClean();
                const tm = _nowTime();
                await pushIdHistory(orderId, {
                    Type: "CANCELLED",
                    BatchKey: batchId,
                    Batch: b.name || batchId,
                    Carrier: b.carrier || "N/A",
                    User: payload.user,
                    dateClean: dc,
                    time: tm,
                    Tracking: "",
                    Items_or_Content: "",
                    Details: "Reason: " + payload.reason
                });
            }catch(err){
                console.error("cancelBatchId pushIdHistory error", err);
            }

            alert(`ID ${orderId} cancelado com sucesso.`);
        } catch (e) {
            console.error(e);
            alert("Erro ao cancelar o ID.");
        }
    }

    // Alias (compat): some older UI code may call cancelExpectedId
    function cancelExpectedId(batchId, orderId, wasPacked){
        return cancelBatchId(batchId, orderId, wasPacked);
    }


</script>


<script>
/* === STRONG PAGE PROFILE GUARD (ADMIN) === */
(function(){
  var PROFILE = "ADMIN";
  var ALLOWED = ['sec-overview', 'sec-office', 'sec-search', 'sec-cross', 'sec-reports', 'sec-performance', 'sec-masterdata'];

  function isAllowed(id){ return !!id && ALLOWED.indexOf(String(id)) !== -1; }

  function removeDisallowedNav(){
    var nodes = Array.from(document.querySelectorAll(".nav-item, .nav-btn, .tab-btn, button, a"));
    nodes.forEach(function(el){
      var oc = el.getAttribute("onclick") || "";
      var m = oc.match(/\btab\s*\(\s*['"]([^'"]+)['"]/);
      if (m && m[1] && !isAllowed(m[1])) {
        el.parentNode && el.parentNode.removeChild(el);
      }
    });
  }

  function hideDisallowedSections(){
    document.querySelectorAll(".section").forEach(function(sec){
      if (!isAllowed(sec.id)) {
        sec.style.display = "none";
        sec.classList.remove("active");
      }
    });
  }

  function forceAllowedSection(){
    var active = document.querySelector(".section.active");
    if (active && !isAllowed(active.id)) active.classList.remove("active");

    // if none active, activate first allowed section that exists
    var any = document.querySelector(".section.active");
    if (any && isAllowed(any.id)) return;

    for (var i=0;i<ALLOWED.length;i++) {
      var s = document.getElementById(ALLOWED[i]);
      if (s) {
        document.querySelectorAll(".section").forEach(function(x){ x.classList.remove("active"); });
        s.classList.add("active");
        s.style.display = "block";
        break;
      }
    }
  }

  function addBadge(){
    if (document.getElementById("__profile_badge")) return;
    var d=document.createElement("div");
    d.id="__profile_badge";
    d.textContent = PROFILE + " PAGE";
    d.style.position="fixed";
    d.style.right="12px";
    d.style.bottom="12px";
    d.style.zIndex="99999";
    d.style.padding="10px 12px";
    d.style.borderRadius="14px";
    d.style.background="rgba(0,0,0,0.75)";
    d.style.color="#fff";
    d.style.fontWeight="900";
    d.style.fontFamily="system-ui, -apple-system, Segoe UI, Roboto, Arial";
    d.style.fontSize="12px";
    document.body.appendChild(d);
  }

  // Block navigation to disallowed tabs even if someone calls tab() manually
  function wrapTab(){
    if (typeof window.tab !== "function") return;
    if (window.__tab_wrapped) return;
    window.__tab_wrapped = true;
    var _tab = window.tab;
    window.tab = function(id, el){
      if (!isAllowed(id)) {
        alert("Sem acesso a este separador nesta p√°gina.");
        return;
      }
      return _tab.call(this, id, el);
    };
  }

  function enforce(){
    try {
      addBadge();
      wrapTab();
      removeDisallowedNav();
      hideDisallowedSections();
      forceAllowedSection();
    } catch(e) { console.error("PROFILE GUARD", e); }
  }

  document.addEventListener("DOMContentLoaded", function(){
    enforce();
    setTimeout(enforce, 300);
    setTimeout(enforce, 1000);
    setTimeout(enforce, 2500);
  });
  // keep enforcing after auth UI swaps
  setInterval(function(){
    var main = document.getElementById("main-interface");
    if (main && main.style.display !== "none") enforce();
  }, 1200);
})();
</script>


<script>
// ===== ADMIN BADGE =====
(function(){
  function setAdminBadge(){
    var b=document.getElementById('__app_badge');
    if(b){
      b.textContent = 'ADMIN PAGE';
      b.style.background = '#22c55e';
    }
    var r=document.getElementById('__role_badge');
    if(r){ r.textContent = 'Role: ADMIN'; r.style.background='#1f2937'; }
  }
  document.addEventListener('DOMContentLoaded', function(){
    setTimeout(setAdminBadge, 100);
    setTimeout(setAdminBadge, 800);
  });
})();
</script>


<script>
// ===== UI TOP BAR + ERROR OVERLAY (robust auth binding) =====
(function(){
  function ensureErrorOverlay(){
    if(document.getElementById('__err_overlay')) return;
    var d=document.createElement('div');
    d.id='__err_overlay';
    d.style.position='fixed';
    d.style.inset='0';
    d.style.zIndex='999999';
    d.style.background='rgba(0,0,0,0.85)';
    d.style.color='#fff';
    d.style.padding='20px';
    d.style.fontFamily='monospace';
    d.style.overflow='auto';
    d.style.display='none';
    document.body.appendChild(d);
  }
  function showErr(msg){
    try{
      ensureErrorOverlay();
      var d=document.getElementById('__err_overlay');
      d.style.display='block';
      d.innerHTML='<h2 style="margin:0 0 10px 0;">Erro no JavaScript</h2><pre style="white-space:pre-wrap;">'+String(msg)+'</pre>';
    }catch(_){}
  }
  window.__showErr = showErr;
  window.addEventListener('error', function(e){
    showErr((e && e.message ? e.message : 'Erro') + '\n' + (e && e.filename ? e.filename : '') + ':' + (e && e.lineno ? e.lineno : '') );
  });
  window.addEventListener('unhandledrejection', function(e){
    var r = e && e.reason ? e.reason : null;
    var msg = 'Promise rejection: ' + (r && r.code ? (r.code + ' - ' + r.message) : String(r));
    showErr(msg);
  });

  function ensureTopBar(){
    if(document.getElementById('__topbar')) return;
    var bar=document.createElement('div');
    bar.id='__topbar';
    bar.style.position='sticky';
    bar.style.top='0';
    bar.style.zIndex='99999';
    bar.style.background='#0f172a';
    bar.style.color='white';
    bar.style.padding='10px 14px';
    bar.style.display='flex';
    bar.style.alignItems='center';
    bar.style.justifyContent='space-between';
    bar.style.gap='10px';
    bar.style.fontFamily='system-ui, -apple-system, Segoe UI, Roboto, Arial';
    bar.innerHTML = '<div style="display:flex; gap:12px; align-items:center; flex-wrap:wrap;">'
      + '<span id="__app_badge" style="font-weight:900; padding:6px 10px; border-radius:999px; background:#334155;">APP</span>'
      + '<span id="__user_badge" style="font-weight:800;">User: -</span>'
      + '<span id="__role_badge" style="font-weight:900; padding:6px 10px; border-radius:999px; background:#1f2937;">Role: -</span>'
      + '<span id="__db_badge" style="font-weight:900; padding:6px 10px; border-radius:999px; background:#7c2d12;">DB: ?</span>'
      + '</div>'
      + '<div style="display:flex; gap:10px; align-items:center;">'
      + '<button id="__btn_logout" style="cursor:pointer; border:none; border-radius:10px; padding:8px 12px; font-weight:900; background:#ef4444; color:white;">Logout</button>'
      + '</div>';
    document.body.insertBefore(bar, document.body.firstChild);

    document.getElementById('__btn_logout').onclick=function(){
      try{
        if(window.auth && auth.signOut) return auth.signOut();
        if(window.firebase && firebase.auth) return firebase.auth().signOut();
      }catch(e){
        alert('Logout failed');
      }
    };
  }

  function setBadge(id, txt, bg){
    var el=document.getElementById(id);
    if(!el) return;
    el.textContent = txt;
    if(bg) el.style.background = bg;
  }

  function bindAuthListener(){
    // Try multiple ways to reach auth instance (auth var or firebase.auth())
    var authInst = null;
    try { if (window.auth && auth.onAuthStateChanged) authInst = auth; } catch(_){}
    if(!authInst){
      try { if (window.firebase && firebase.auth) authInst = firebase.auth(); } catch(_){}
    }
    if(!authInst || !authInst.onAuthStateChanged) return false;

    if(window.__topbar_auth_bound) return true;
    window.__topbar_auth_bound = true;

    authInst.onAuthStateChanged(function(u){
      if(u && u.email){
        setBadge('__user_badge', 'User: ' + u.email);
        // infer role by domain if present
        var email = String(u.email).toLowerCase();
        var role = (email.endsWith('@admin.com') ? 'ADMIN' : (email.endsWith('@wh.com') ? 'WH' : 'USER'));
        setBadge('__role_badge', 'Role: ' + role, '#1f2937');
      } else {
        setBadge('__user_badge', 'User: -');
      }
    });
    return true;
  }

  function bindDbListener(){
    if(window.__topbar_db_bound) return;
    var dbInst = null;
    try { if(window.db && db.ref) dbInst = db; } catch(_){}
    if(!dbInst){
      try { if(window.firebase && firebase.database) dbInst = firebase.database(); } catch(_){}
    }
    if(!dbInst || !dbInst.ref) return;

    window.__topbar_db_bound = true;
    try{
      dbInst.ref('.info/connected').on('value', function(snap){
        var ok = !!snap.val();
        setBadge('__db_badge', 'DB: ' + (ok ? 'CONNECTED' : 'OFFLINE'), ok ? '#166534' : '#7c2d12');
      });
    }catch(e){
      setBadge('__db_badge', 'DB: UNKNOWN', '#7c2d12');
    }
  }

  function loopBind(){
    ensureTopBar();
    bindDbListener();
    if(bindAuthListener()) return;
    // keep trying for a few seconds until firebase/auth is initialized
  }

  document.addEventListener('DOMContentLoaded', function(){
    ensureTopBar();
    loopBind();
    var tries=0;
    var t=setInterval(function(){
      tries++;
      loopBind();
      if(window.__topbar_auth_bound && window.__topbar_db_bound) clearInterval(t);
      if(tries>60) clearInterval(t);
    }, 250);
  });
})();
</script>


<script>
// ===== OVERVIEW-ONLY SUMMARY GUARD =====
(function(){
  function enforceOverviewOnly(){
    try{
      var overview = document.getElementById('sec-overview');
      if(!overview) return;

      // Find summary blocks inside overview
      var summaries = overview.querySelectorAll('[data-overview-summary], .overview-cards, .stats, .summary, .dashboard');

      // Hide any summary blocks that are outside overview
      document.querySelectorAll('[data-overview-summary], .overview-cards, .stats, .summary, .dashboard').forEach(function(el){
        if(!overview.contains(el)){
          el.style.display = 'none';
        }
      });

      // Ensure summaries inside overview are visible only when overview is active
      summaries.forEach(function(el){
        if(overview.classList.contains('active')){
          el.style.display = '';
        } else {
          el.style.display = 'none';
        }
      });
    }catch(e){ console.error(e); }
  }

  document.addEventListener('DOMContentLoaded', function(){
    enforceOverviewOnly();
    setTimeout(enforceOverviewOnly, 300);
  });

  // Wrap tab function to re-apply
  if(typeof window.tab === 'function' && !window.__overviewTabWrapped){
    var _origTab = window.tab;
    window.tab = function(secId, el){
      var r = _origTab.apply(this, arguments);
      setTimeout(enforceOverviewOnly, 50);
      return r;
    };
    window.__overviewTabWrapped = true;
  }
})();
</script>


<script>
// ===== AFTER LOGIN: ALWAYS OPEN OVERVIEW =====
(function(){
  function goOverview(){
    try{
      // If already on overview, do nothing
      var ov = document.getElementById('sec-overview');
      if(ov && ov.classList.contains('active')) return;

      // Try to use existing tab() with matching nav item
      if(typeof window.tab === 'function'){
        var nav = Array.from(document.querySelectorAll('.nav-item, .nav-btn, .tab-btn, button, a'))
          .find(function(el){
            var oc = el.getAttribute('onclick') || '';
            return oc.indexOf("'sec-overview'") !== -1 || oc.indexOf('"sec-overview"') !== -1;
          });
        if(nav) window.tab('sec-overview', nav);
        else {
          // fallback: activate section by class
          document.querySelectorAll('.section').forEach(function(s){ s.classList.remove('active'); s.style.display = 'none'; });
          if(ov){ ov.classList.add('active'); ov.style.display = 'block'; }
        }
      } else {
        // fallback
        document.querySelectorAll('.section').forEach(function(s){ s.classList.remove('active'); s.style.display = 'none'; });
        if(ov){ ov.classList.add('active'); ov.style.display = 'block'; }
      }
    }catch(e){ console.error(e); }
  }

  function bind(){
    // bind to auth state if possible
    try{
      var authInst = null;
      if(window.auth && auth.onAuthStateChanged) authInst = auth;
      else if(window.firebase && firebase.auth) authInst = firebase.auth();
      if(!authInst || !authInst.onAuthStateChanged) return false;

      if(window.__goOverviewBound) return true;
      window.__goOverviewBound = true;

      authInst.onAuthStateChanged(function(u){
        if(u){
          // wait a bit for UI to render
          setTimeout(function(){
            var main = document.getElementById('main-interface');
            if(main) main.style.display = 'block';
            goOverview();
          }, 200);
          setTimeout(goOverview, 800);
        }
      });
      return true;
    }catch(e){ return false; }
  }

  document.addEventListener('DOMContentLoaded', function(){
    // try bind repeatedly until firebase initializes
    var tries=0;
    var t=setInterval(function(){
      tries++;
      if(bind()) clearInterval(t);
      if(tries>60) clearInterval(t);
    }, 250);
  });
})();
</script>


<script>
// ===== MOVE OVERVIEW CARDS INTO OVERVIEW ONLY =====
(function(){
  function moveCardsIntoOverview(){
    try{
      var overview = document.getElementById('sec-overview');
      if(!overview) return;

      // This is the KPI/cards grid we want only in Overview
      var grid = document.querySelector('.dashboard-grid');
      if(!grid) return;

      // If it's already inside overview, nothing to do
      if(overview.contains(grid)) return;

      // Move it to the top of the overview section
      overview.insertBefore(grid, overview.firstChild);
    }catch(e){ console.error(e); }
  }

  function showOnlyWhenOverviewActive(){
    try{
      var grid = document.querySelector('#sec-overview .dashboard-grid') || document.querySelector('.dashboard-grid');
      var overview = document.getElementById('sec-overview');
      if(!grid || !overview) return;
      grid.style.display = overview.classList.contains('active') ? '' : 'none';
    }catch(e){ console.error(e); }
  }

  function enforce(){
    moveCardsIntoOverview();
    showOnlyWhenOverviewActive();
  }

  document.addEventListener('DOMContentLoaded', function(){
    enforce();
    setTimeout(enforce, 200);
    setTimeout(enforce, 800);
  });

  // Wrap tab to re-enforce after navigation
  if(typeof window.tab === 'function' && !window.__tabWrappedForCards){
    var orig = window.tab;
    window.tab = function(secId, el){
      var r = orig.apply(this, arguments);
      setTimeout(enforce, 50);
      return r;
    };
    window.__tabWrappedForCards = true;
  }
})();
</script>


<script>
// ===== FIX: CLEAR INLINE DISPLAY ON SECTIONS (prevents Overview leaking into other tabs) =====
(function(){
  function clearInlineDisplays(){
    try{
      document.querySelectorAll('.section').forEach(function(s){
        // Remove inline display overrides so CSS .section/.section.active controls visibility
        if (s && s.style) s.style.display = '';
      });
    }catch(e){ console.error(e); }
  }

  document.addEventListener('DOMContentLoaded', function(){
    clearInlineDisplays();
    setTimeout(clearInlineDisplays, 300);
    setTimeout(clearInlineDisplays, 1200);
  });

  // Wrap tab() to always clear inline display before switching
  if(typeof window.tab === 'function' && !window.__tabWrappedClearDisplay){
    var origTab = window.tab;
    window.tab = function(id, el){
      clearInlineDisplays();
      var r = origTab.apply(this, arguments);
      clearInlineDisplays();
      return r;
    };
    window.__tabWrappedClearDisplay = true;
  }
})();
</script>


<script>
// ===== GLOBAL HELPERS (Search needs these) =====
(function(){
  // minimal formatter if not present
  if(typeof window._fmt !== 'function'){
    window._fmt = function(v){ return (v===undefined || v===null) ? "" : String(v); };
  }

  function _normalizeProductToken(t){
    t = window._fmt(t).trim();
    if(!t) return "";
    try{
      var key = t.toUpperCase();
      if(window.masterProductsDB && masterProductsDB[key]) return window._fmt(masterProductsDB[key]).trim();
    }catch(e){}
    return t;
  }

  function _splitProductsFieldImpl(prodsField){
    if(prodsField === undefined || prodsField === null) return [];
    if(Array.isArray(prodsField)) return prodsField.map(_normalizeProductToken).filter(Boolean);
    if(typeof prodsField === 'object') return Object.keys(prodsField).map(_normalizeProductToken).filter(Boolean);
    var s = String(prodsField).trim();
    if(!s || s.toLowerCase()==='no items') return [];
    return s.split('|').map(function(x){ return _normalizeProductToken(x); }).filter(Boolean);
  }

  // Expose globally if missing (or if scoped in another block)
  if(typeof window._splitProductsField !== 'function'){
    window._splitProductsField = _splitProductsFieldImpl;
  }
})();
</script>

</body>
</html>
